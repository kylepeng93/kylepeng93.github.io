<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>archlinux安装指南</title>
    <url>/2021/10/02/archlinux-install-guide/</url>
    <content><![CDATA[<h2 id="Arch-Linux是什么"><a href="#Arch-Linux是什么" class="headerlink" title="Arch Linux是什么"></a>Arch Linux是什么</h2><p>Arch Linux是一款滚动更新的GNU/Linux发行版，致力于提供最新的稳定版软件，相较于其他图形界面的发行版，Arch Linux只能在命令行界面进行安装，且默认不带任何桌面环境。（非特别说明，后文将GNU/Linux简称为Linux）</p>
<h2 id="Arch-Linux有什么优势"><a href="#Arch-Linux有什么优势" class="headerlink" title="Arch Linux有什么优势"></a>Arch Linux有什么优势</h2><p>相较于其他基于Debian或者Redhat的发行版，Arch Linux提供了自己的包管理器——pacman，而且支持用户软件仓库（AUR）。基于这个特性，大大增加了Arch Linux系统原生软件的数量。而良好的软件生态正是Arch Linux的一大利器。</p>
<h2 id="Arch-Linux的安装"><a href="#Arch-Linux的安装" class="headerlink" title="Arch Linux的安装"></a>Arch Linux的安装</h2><p>对于大部分非专业人士而言，习惯了Windows的图形界面之后，突然使用命令行操作软件往往变得非常困难，更不用说安装系统了，尽管Arch Linux拥有详细的由社区维护的安装指南Wiki，但也因此劝退了一些习惯了windows之后想要尝试linux系统的新手，基于此，本文特地将自己安装Arch Linux过程中的经历以及出现的问题做个说明，作为Arch Linux安装wiki的补充，不失为帮助更多的人能够接触到linux的一种方法（windows固然很优秀，但<strong>自由/开源软件</strong>才是软件开发的未来）。</p>
<h3 id="1、获取最新版镜像"><a href="#1、获取最新版镜像" class="headerlink" title="1、获取最新版镜像"></a>1、获取最新版镜像</h3><p>官方下载网站：<a href="https://archlinux.org/download/">https://archlinux.org/download/</a></p>
<h2 id="2、制作启动盘"><a href="#2、制作启动盘" class="headerlink" title="2、制作启动盘"></a>2、制作启动盘</h2><p>准备一个空的U盘，和一台已安装好linux系统的机器，使用如下命令进行写盘：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd bs=4MB <span class="keyword">if</span>=你的安装镜像路径 of=你的U盘路径 status=progress</span><br></pre></td></tr></table></figure>

<blockquote>
<p>of参数通常是/dev/sdb，其中sdb是你的U盘路径，注意不要带数字后缀，类似sdb1。另外，写盘之前必须使用umount命令卸载的U盘（如果被自动挂载的话）。</p>
</blockquote>
<h3 id="3、从U盘启动，开始安装"><a href="#3、从U盘启动，开始安装" class="headerlink" title="3、从U盘启动，开始安装"></a>3、从U盘启动，开始安装</h3><p>需要注意的是，为了确保可以正常从启动盘引导，需要关闭主板的安全启动选项（可以在安装完成之后重新打开），关闭方式因主板厂商不同而有所差异。具体如何关闭可以自行百度。</p>
<p>重启主机之后，进入BIOS或者直接通过功能键选择启动顺序，将USB设备作为第一启动项，启动之后选择<code>Arch Linux install medium</code>进入系统安装界面。</p>
<h3 id="4、验证启动模式"><a href="#4、验证启动模式" class="headerlink" title="4、验证启动模式"></a>4、验证启动模式</h3><p>如果使用的是UEFI模式，则可以使用如下命令验证:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure>

<p>如果命令正常打印出一系列文件和目录，且没有任何错误，则表明当前是以UEFI模式启动。否则则是以BIOS或者CMS模式启动。</p>
<h2 id="5、联网"><a href="#5、联网" class="headerlink" title="5、联网"></a>5、联网</h2><p>一般来说，我们可以直接插入网线联网，或者使用外置网卡。比如手机的USB网络共享。</p>
<h2 id="6、调整时区"><a href="#6、调整时区" class="headerlink" title="6、调整时区"></a>6、调整时区</h2><p>使用<code>timedatectl</code>可以查看并设置时区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用ntp（网络时间协议）</span></span><br><span class="line">timedatectl set-ntp <span class="literal">true</span></span><br><span class="line"><span class="comment"># 列出当前可用的时区</span></span><br><span class="line">timedatectl list-timezones</span><br><span class="line"><span class="comment"># 设置选择的时区</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<h2 id="7、磁盘分区"><a href="#7、磁盘分区" class="headerlink" title="7、磁盘分区"></a>7、磁盘分区</h2><p>查看当前可用磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>选择将要使用的磁盘，假设是<code>/dev/sda</code>，执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sda</span><br></pre></td></tr></table></figure>

<p>进入分区界面之后，使用<code>m</code>查看具体的分区指令。一般步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建分区表</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用aliyun的maven仓库初始化gradle</title>
    <url>/2021/03/16/aliyun-gradle-config/</url>
    <content><![CDATA[<h2 id="在linux中使用gradle命令行构建程序时，使用国内镜像可以大大加快我们的构建过程，节约我们的时间，下面就如何配置aliyun仓库作为gradle的默认仓库作出说明。"><a href="#在linux中使用gradle命令行构建程序时，使用国内镜像可以大大加快我们的构建过程，节约我们的时间，下面就如何配置aliyun仓库作为gradle的默认仓库作出说明。" class="headerlink" title="在linux中使用gradle命令行构建程序时，使用国内镜像可以大大加快我们的构建过程，节约我们的时间，下面就如何配置aliyun仓库作为gradle的默认仓库作出说明。"></a>在linux中使用gradle命令行构建程序时，使用国内镜像可以大大加快我们的构建过程，节约我们的时间，下面就如何配置aliyun仓库作为gradle的默认仓库作出说明。</h2><ol>
<li>如果只想对单个项目生效，那么可以在项目的<code>build.gradle</code>中添加如下配置：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">buildscript</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">repositories</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123;url &#x27;https://maven.aliyun.com/repository/google/&#x27;&#125;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123;url &#x27;https://maven.aliyun.com/repository/jcenter/&#x27;&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">dependencies</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">classpath</span>: <span class="string">&#x27;com.android.tools.build:gradle:2.2.3&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">allprojects</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">repositories</span> <span class="string">&#123;</span></span><br><span class="line">         <span class="attr">maven</span> <span class="string">&#123; url &#x27;https://maven.aliyun.com/repository/google/&#x27; &#125;</span></span><br><span class="line">         <span class="attr">maven</span> <span class="string">&#123; url &#x27;https://maven.aliyun.com/repository/jcenter/&#x27;&#125; </span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>如果是对所有项目生效，那么需要在用户的家目录下面的.gradle目录下创建<code>init.gradle</code>文件，内容如下：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">allprojects&#123;</span></span><br><span class="line">    <span class="attr">repositories</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">def</span> <span class="string">ALIYUN_REPOSITORY_URL = &#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">        <span class="attr">def</span> <span class="string">ALIYUN_JCENTER_URL = &#x27;https://maven.aliyun.com/repository/jcenter/&#x27;</span></span><br><span class="line">        <span class="attr">def</span> <span class="string">ALIYUN_GOOGLE_URL = &#x27;https://maven.aliyun.com/repository/google/&#x27;</span></span><br><span class="line">        <span class="attr">def</span> <span class="string">ALIYUN_GRADLE_PLUGIN_URL = &#x27;https://maven.aliyun.com/repository/gradle-plugin/&#x27;</span></span><br><span class="line">        <span class="attr">all</span> <span class="string">&#123; ArtifactRepository repo -&gt;</span></span><br><span class="line">            <span class="meta">if(repo</span> <span class="string">instanceof MavenArtifactRepository)&#123;</span></span><br><span class="line">                <span class="attr">def</span> <span class="string">url = repo.url.toString()</span></span><br><span class="line">                <span class="attr">if</span> <span class="string">(url.startsWith(&#x27;https://repo1.maven.org/maven2/&#x27;)) &#123;</span></span><br><span class="line">                    <span class="meta">project.logger.lifecycle</span> <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                    <span class="attr">remove</span> <span class="string">repo</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">if</span> <span class="string">(url.startsWith(&#x27;https://jcenter.bintray.com/&#x27;)) &#123;</span></span><br><span class="line">                    <span class="meta">project.logger.lifecycle</span> <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_JCENTER_URL.&quot;</span></span><br><span class="line">                    <span class="attr">remove</span> <span class="string">repo</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">if</span> <span class="string">(url.startsWith(&#x27;https://dl.google.com/dl/android/maven2/&#x27;)) &#123;</span></span><br><span class="line">                    <span class="meta">project.logger.lifecycle</span> <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_GOOGLE_URL.&quot;</span></span><br><span class="line">                    <span class="attr">remove</span> <span class="string">repo</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">if</span> <span class="string">(url.startsWith(&#x27;https://plugins.gradle.org/m2/&#x27;)) &#123;</span></span><br><span class="line">                    <span class="meta">project.logger.lifecycle</span> <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_GRADLE_PLUGIN_URL.&quot;</span></span><br><span class="line">                    <span class="attr">remove</span> <span class="string">repo</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">            <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123; url ALIYUN_REPOSITORY_URL &#125;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123; url ALIYUN_JCENTER_URL &#125;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123; url ALIYUN_GOOGLE_URL &#125;</span></span><br><span class="line">        <span class="attr">maven</span> <span class="string">&#123; url ALIYUN_GRADLE_PLUGIN_URL &#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>下载神器aria2使用手册</title>
    <url>/2021/04/01/aria2-manual/</url>
    <content><![CDATA[<h2 id="aria2是什么东西"><a href="#aria2是什么东西" class="headerlink" title="aria2是什么东西"></a>aria2是什么东西</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>aria2</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title>国庆假期之后返回上海后的感想</title>
    <url>/2021/10/08/back-to-shanghai-after-guoqing-holiday/</url>
    <content><![CDATA[<h2 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h2><p>兜兜转转，一咋眼的功夫，来上海工作已经两年有余了，刚来上海找工作的那段时间其实心里是没底的，毕竟在上一家公司虽然说也有了两年的工作经验，可是真正学到的东西却没有多少，</p>
]]></content>
      <categories>
        <category>人生</category>
      </categories>
      <tags>
        <tag>个人感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>bash中的常用快捷方式</title>
    <url>/2021/03/14/bash-shortcut-manual/</url>
    <content><![CDATA[<h2 id="以alt为辅助键的快捷键"><a href="#以alt为辅助键的快捷键" class="headerlink" title="以alt为辅助键的快捷键"></a>以<code>alt</code>为辅助键的快捷键</h2><ol>
<li>alt+A 跳转到行首</li>
<li>alt+B 跳转到光标后面一个单词长度的位置</li>
<li>alt+C 中断bash中正在执行的任务</li>
<li>alt+D 删除位于光标后面的所有字符</li>
<li>alt+F 移动到光标前面一个单词长度的位置</li>
<li>alt+T 交换光标位置前后的两个单词的位置</li>
<li>alt+U 将位于光标位置后面的第一个单词全部转换成大写字母</li>
<li>alt+L 和alt+U相反，将位于光标位置后面的第一个单词全部转换成小写字母</li>
<li>alt+R 撤销当前命令所有的改变（等同于清空当前所有手动输入过的字符）</li>
<li>alt+. 使用上一个命令的最后一个单词（以空格来区分）</li>
</ol>
<h2 id="以ctrl为辅助键的快捷键"><a href="#以ctrl为辅助键的快捷键" class="headerlink" title="以ctrl为辅助键的快捷键"></a>以<code>ctrl</code>为辅助键的快捷键</h2><ol>
<li>ctrl+A 移动到行首</li>
<li>ctrl+B 向光标后面移动一个字符</li>
<li>ctrl+C 终止正在执行的任务</li>
<li>ctrl+D 向光标后面删除一个字符</li>
<li>ctrl+E 移动到行尾</li>
<li>ctrl+H 删除光标前面的一个字符，相当于退格键</li>
<li>ctrl+J 相当于<code>enter</code>键</li>
<li>ctrl+K 删除所有位于光标后面的字符</li>
<li>ctrl+L 清空屏幕</li>
<li>ctrl+R 查询历史命令</li>
<li>ctrl+O 执行ctrl+R查询出来的命令</li>
<li>ctrl+T 交换最后两个字符</li>
<li>ctrl+U 删除位于光标位置前的字符</li>
<li>ctrl+W 删除光标位置前的一个单词</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>!! 重复执行上一条命令</li>
<li>ESC+T 交换最后两个单词的位置</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>shortcut</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全读后感</title>
    <url>/2021/03/18/code-complete-after-reading/</url>
    <content><![CDATA[<h2 id="利用隐喻对编程进行更加深刻的理解"><a href="#利用隐喻对编程进行更加深刻的理解" class="headerlink" title="利用隐喻对编程进行更加深刻的理解"></a>利用隐喻对编程进行更加深刻的理解</h2><ol>
<li>公式与启发之间的区别是微妙的，体现在它们与答案之间的直接程度：公式直接给予指令;而启发则告诉你该怎样找到这些指令，或者告诉你到哪里寻找它们。</li>
<li>隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。<blockquote>
<p>为每个工作选择合适的工具，是成为一个优秀程序员的首要素质之一。</p>
</blockquote>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>代码大全</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用netcat工具在两台linux主机之间通信</title>
    <url>/2021/10/02/chat-with-netcat-between-linux-host/</url>
    <content><![CDATA[<h2 id="为什么我们不使用当下流行的即时通讯工具在PC间通信或者传输文件"><a href="#为什么我们不使用当下流行的即时通讯工具在PC间通信或者传输文件" class="headerlink" title="为什么我们不使用当下流行的即时通讯工具在PC间通信或者传输文件"></a>为什么我们不使用当下流行的即时通讯工具在PC间通信或者传输文件</h2><p>目前国内使用率最高的两款即时通讯工具莫过于鹅厂的两款工具——微信和QQ。因为某些众所周知的原因，这两款工具在linux平台要么直接没有，要么只有一个复古的阉割版，功能少的让人怀疑是不是鹅厂直接把10年前的产品直接拿来用了。基于这些现实的问题，对于linux用户来说，其实可替换方案也不是没有，最好的办法就是使用telegram，但在中国，这种方案并不是人人都能够直接拿来用，最直接的原因就是使用这款软件必须要学会科学上网（比如访问谷歌或者油管）。而科学上网在中国处于法律的灰色地带，一般人没有途径也不愿意承担这样的风险。那么作为一名linux用户，只要具备基本的使用命令行的能力，其实方法还是有很多的。这里介绍一种非常方便而且直观的通讯工具——netcat，供大家参考。</p>
<h2 id="netcat是个什么样的工具"><a href="#netcat是个什么样的工具" class="headerlink" title="netcat是个什么样的工具"></a>netcat是个什么样的工具</h2><p>netcat是一款网络工具，可以在基于TCP和UDP网络连接的基础上执行读写操作。</p>
<p>它被设计为一个可靠的后端工具，可以直接在其他程序或者脚本中被使用。同时，它还是一个用来调试和探测网络的工具。因为它可以创建几乎所有你可能需要的连接类型。</p>
<h2 id="netcat有哪些特性"><a href="#netcat有哪些特性" class="headerlink" title="netcat有哪些特性"></a>netcat有哪些特性</h2><ul>
<li>流出和流入连接：例如来自基于TCP或者UDP的任意端口的连接。</li>
<li>隧道模式：它允许创建特殊的隧道，如 UDP 到 TCP，并且可以指定所有网络参数（源主机端口/接受主机端口、监听端口/接口和允许连接到隧道的远程主机）。</li>
<li>使用随机发生器进行端口扫描</li>
<li>高级使用选项：例如传输和接收数据的缓冲发送模式（每 N 秒一行）和 hexdump（到 stderr 或到指定文件）。</li>
<li>可选的 RFC854 telnet 代码解析器和响应器。</li>
</ul>
<h2 id="如何将netcat作为一款即时通讯工具呢"><a href="#如何将netcat作为一款即时通讯工具呢" class="headerlink" title="如何将netcat作为一款即时通讯工具呢"></a>如何将netcat作为一款即时通讯工具呢</h2><ol>
<li><p>首先，我们需要在需要建立通讯的主机上安装netcat工具，使用linux自带的包管理器安装即可。</p>
</li>
<li><p>然后选择一台已经安装好netcat的机器，在终端中执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l -vv -p 12345</span><br></pre></td></tr></table></figure>

<p>其中<code>-l</code>和<code>p</code>表示在本机的12345端口进行监听，并创建一个TCP连接。<code>-vv</code>表示尽可能的展示运行过程中的系统消息，<code>-p</code>表示要监听的端口号。</p>
</li>
<li><p>选择要与监听主机建立连接的机器，在终端中执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 步骤2中创建监听的主机ip 步骤2中创建的监听端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完2、3之后，一条连接已经创建完成，可以开始互发消息了。</p>
</li>
</ol>
<blockquote>
<p>需要注意的是，连接双方发送的消息会全部展示在各自的屏幕上，如果有多于两个以上的连接方则无法区分消息的来源。</p>
</blockquote>
<h2 id="使用netcat传输文件"><a href="#使用netcat传输文件" class="headerlink" title="使用netcat传输文件"></a>使用netcat传输文件</h2><p>netcat还可以用来传输文件</p>
<ol>
<li><p>对接收方执行如下命立：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l -vv -p 12345 &gt; received_file</span><br></pre></td></tr></table></figure>
</li>
<li><p>在发送方执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc 接收方的ip地址 12345 &lt; received_file</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>需要注意的是，这里创建监听的动作是由接收方发起的，而发送方需要和接收方建立连接并发送文件。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>netcat</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下使用crontab工具设置定时任务</title>
    <url>/2021/03/04/cron-manual/</url>
    <content><![CDATA[<h2 id="使用crontab添加定时任务"><a href="#使用crontab添加定时任务" class="headerlink" title="使用crontab添加定时任务"></a>使用crontab添加定时任务</h2><p>crontab -e</p>
<h2 id="cron的格式说明"><a href="#cron的格式说明" class="headerlink" title="cron的格式说明"></a>cron的格式说明</h2><p>分钟 小时 月中日 月份 周中日 你的自动化脚本<br>取值范围：<br>分钟：0-59<br>小时：0-23<br>月中日：1-31<br>月份：1-12<br>周中日：0-6</p>
<h2 id="在指定的时间点调度"><a href="#在指定的时间点调度" class="headerlink" title="在指定的时间点调度"></a>在指定的时间点调度</h2><p>30 08 10 12 * /home/pengkai/myjob.sh<br>上面的调度器会在12月10号的上午8点30分执行myjob.sh脚本。<br>注意，上面最后一个位置使用了*号来表示一周中的每一天。因为已经指定了具体的月日，所以不必再限制那一天是星期几。</p>
<h2 id="查看当前用户下的所有调度任务"><a href="#查看当前用户下的所有调度任务" class="headerlink" title="查看当前用户下的所有调度任务"></a>查看当前用户下的所有调度任务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure>
<p>或者以root用户查看其他用户的任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crontab -u kyle -l</span></span><br></pre></td></tr></table></figure>
<h2 id="每分钟执行一次调度"><a href="#每分钟执行一次调度" class="headerlink" title="每分钟执行一次调度"></a>每分钟执行一次调度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * 你的脚本</span><br></pre></td></tr></table></figure>
<h2 id="一天执行两次"><a href="#一天执行两次" class="headerlink" title="一天执行两次"></a>一天执行两次</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 12,20 * * * 你的脚本</span><br></pre></td></tr></table></figure>
<p>上面的命令会分别在中午12点晚上8点执行你的脚本</p>
<h2 id="指定起止时间并按照固定间隔执行"><a href="#指定起止时间并按照固定间隔执行" class="headerlink" title="指定起止时间并按照固定间隔执行"></a>指定起止时间并按照固定间隔执行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">08-20 * * * 你的脚本</span><br></pre></td></tr></table></figure>
<p>上面的命令会从8点开始执行，然后间隔一个小时再次执行，最后一直到晚上8点截止。</p>
<h2 id="只在工作日的工作时间内执行"><a href="#只在工作日的工作时间内执行" class="headerlink" title="只在工作日的工作时间内执行"></a>只在工作日的工作时间内执行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 09-18 * * 1-5 你的脚本</span><br></pre></td></tr></table></figure>
<p>从周一开始，每天从上午9点开始执行，然后每隔一个小时再次执行，最后一直到下午6点截止。如此往复到周五晚上6点停止执行。下周继续。</p>
<h2 id="每隔10分钟执行一次"><a href="#每隔10分钟执行一次" class="headerlink" title="每隔10分钟执行一次"></a>每隔10分钟执行一次</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/10 * * * * 你的脚本</span><br></pre></td></tr></table></figure>
<h2 id="使用特殊字符指定调度周期"><a href="#使用特殊字符指定调度周期" class="headerlink" title="使用特殊字符指定调度周期"></a>使用特殊字符指定调度周期</h2><p>cron支持的特殊字符<br>@yearly = 0 0 1 1 * ：每年的1月1日执行<br>@daily = 0 0 * * * ： 每天的0点执行<br>@monthly = 0 0 1 * * ：每个月的1号的0点执行<br>@hourly = 0 * * * * ：每个小时执行一次<br>@reboot = 计算器启动时执行</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>curl命令常见用法</title>
    <url>/2021/01/08/curl-command-usage/</url>
    <content><![CDATA[<h2 id="发送post请求"><a href="#发送post请求" class="headerlink" title="发送post请求"></a>发送post请求</h2><ul>
<li>参数类型为<code>application/json</code></li>
</ul>
<ol>
<li><p>常规用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;&#x27;</span> -H <span class="string">&quot;Content-Type: application/json&quot;</span> -X POST http://localhost:8080/your_interface_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用json文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&quot;@data.json&quot;</span> -X POST http://localhost:8080/your_interface_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>data.json</strong></p>
<hr>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<ul>
<li>参数类型为<code>application/x-www-form-urlencoded</code></li>
</ul>
<ol>
<li><p>常规用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span> -X POST http://localhost:8080/your_interface_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用data文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&quot;@data.txt&quot;</span> -X POST http://localhost/your_interface_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>data.txt</strong></p>
<hr>
<p>param1=value1&amp;param2=value2</p>
</blockquote>
</li>
</ol>
<ul>
<li>发送GET请求</li>
</ul>
<ol>
<li><p>常规用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X GET http://localhost:8080/user/info?id=1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要显示响应头信息，则可以加上<code>-i</code>参数。</p>
</blockquote>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习手册</title>
    <url>/2021/03/12/design-pattern-tutorial/</url>
    <content><![CDATA[<h2 id="设计模式的类别"><a href="#设计模式的类别" class="headerlink" title="设计模式的类别"></a>设计模式的类别</h2><ul>
<li>创造性模式（creational）<blockquote>
<p>创造型模式控制了对象的创建和类的实例化；</p>
</blockquote>
</li>
<li>结构性模式（structural）<blockquote>
<p>结构型设计模式控制了类和对象之间的关系</p>
</blockquote>
</li>
<li>表现型模式（behavioral)<blockquote>
<p>表现型设计模式控制了对象之间的交流和交互</p>
</blockquote>
<h2 id="设计模式带来的影响范围——确定了解决方案的关注点"><a href="#设计模式带来的影响范围——确定了解决方案的关注点" class="headerlink" title="设计模式带来的影响范围——确定了解决方案的关注点"></a>设计模式带来的影响范围——确定了解决方案的关注点</h2></li>
<li>对象层面的影响范围——解决对象关系的问题<br>作用于运行期间，对象拥有动态的行为</li>
<li>类层面的影响范围——解决类关系的问题<br>作用于编译期间，类拥有静态的行为<h2 id=""><a href="#" class="headerlink" title=""></a></h2></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用手冊</title>
    <url>/2021/03/12/docker-manual/</url>
    <content><![CDATA[<h2 id="启动docker实例"><a href="#启动docker实例" class="headerlink" title="启动docker实例"></a>启动docker实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker start 你的镜像名称</span><br></pre></td></tr></table></figure>
<h2 id="关闭docker实例"><a href="#关闭docker实例" class="headerlink" title="关闭docker实例"></a>关闭docker实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker stop 你的镜像名称</span><br></pre></td></tr></table></figure>
<h2 id="查看所有的本地镜像"><a href="#查看所有的本地镜像" class="headerlink" title="查看所有的本地镜像"></a>查看所有的本地镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>
<p>或者带上选项<code>q</code>则只会列出容器id（类似369a959e3402）</p>
<h2 id="查看指定命令的帮助手册（有哪些可用选项）"><a href="#查看指定命令的帮助手册（有哪些可用选项）" class="headerlink" title="查看指定命令的帮助手册（有哪些可用选项）"></a>查看指定命令的帮助手册（有哪些可用选项）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker 你的命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h2 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名</span><br></pre></td></tr></table></figure>
<h2 id="安装并启动镜像"><a href="#安装并启动镜像" class="headerlink" title="安装并启动镜像"></a>安装并启动镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name &lt;容器名称&gt; --hostname &lt;容器主机名&gt; -p 15672:15672 -p 5672:5672 镜像名称</span><br></pre></td></tr></table></figure>
<p>注意，该命令会先在本地查找镜像是否已经存在，如果不存在，则从远程仓库下载，并创建该镜像的一个实例。其中，–name用来指定被创建容器的名称，–hostname被用来指定被创建容器的主机名，-p被用来映射容器端口和本地运行环境端口，最后的镜像名称为远程仓库中已存在的镜像名；-it,其中的i表示交互式运行，t表示开启一个伪终端。</p>
<h2 id="删除指定的容器实例"><a href="#删除指定的容器实例" class="headerlink" title="删除指定的容器实例"></a>删除指定的容器实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm 容器名称或者容器id</span><br></pre></td></tr></table></figure>
<h2 id="挂载本地目录，并映射到容器内的存储目录"><a href="#挂载本地目录，并映射到容器内的存储目录" class="headerlink" title="挂载本地目录，并映射到容器内的存储目录"></a>挂载本地目录，并映射到容器内的存储目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name mongo -v /mongodb/data/db:/data/db -p 27017:27017 -d mongo:latest</span><br></pre></td></tr></table></figure>
<p>该命令使用<code>-v</code>选项（volumn）将本地目录<code>/mongodb/data/db</code>挂载到容器内的目录<code>/data/db</code>，并使用<code>-d</code>选项将容器实例以后台进程的形式运行。</p>
<h2 id="进入容器实例内部"><a href="#进入容器实例内部" class="headerlink" title="进入容器实例内部"></a>进入容器实例内部</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongodb bash</span><br></pre></td></tr></table></figure>
<p>该命令会开启一个新的bash shell,而该bash shell对应的是容器内的环境。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式搜索引擎-elasticsearch</title>
    <url>/2021/08/20/elasticsearch-tutorial/</url>
    <content><![CDATA[<h2 id="1-elatsticsearch（简写为es）是什么"><a href="#1-elatsticsearch（简写为es）是什么" class="headerlink" title="1. elatsticsearch（简写为es）是什么"></a>1. elatsticsearch（简写为es）是什么</h2><p>它是一个实时的分布式、开源的全文本查询和分析引擎，基于java语言开发。</p>
<h2 id="2-es可以做什么"><a href="#2-es可以做什么" class="headerlink" title="2. es可以做什么"></a>2. es可以做什么</h2><p>它可以在SPA（single page application-单页应用）中被使用，为用户提供高速的数据查询和分析。且原生支持java应用。</p>
<h2 id="3-主要特性"><a href="#3-主要特性" class="headerlink" title="3. 主要特性"></a>3. 主要特性</h2><p>它有如下几个主要特性：</p>
<ul>
<li>可拓展性强，支持高达千兆字节（GB）的数据（不管是结构性的还是非结构性的）；</li>
<li>可以作为类似MongoDB和RavenDB等文档存储数据库的替代品；</li>
<li>使用非规范化来提高搜索性能；</li>
<li>企业级的搜索引擎，被大型公司广泛使用；</li>
<li>开源工具，且使用Apache许可证。</li>
</ul>
<h2 id="4-关键性的概念"><a href="#4-关键性的概念" class="headerlink" title="4. 关键性的概念"></a>4. 关键性的概念</h2><ul>
<li>节点：表示单个运行的es实例，es可以在单台服务器上运行多个实例，这完全取决于服务器的物理内存和处理器能力；</li>
<li>集群：一个或者多个节点的集合，在逻辑上提供了集中的数据索引和查询能力，通常表现在横跨多个节点获取完整数据的能力。</li>
<li>索引：不同类型的文档和他们的属性的集合。在关系型数据库中，索引一般用于提升查询性能。</li>
<li>文档：一个使用JSON格式定义的字段集合，而这些字段定义了数据查询的规则。每个文档都属于一种类型并驻留在索引中，每个文档都与一个称为 UID 的唯一标识符相关联。</li>
<li>分片：索引被横向拆分成不同的分片，这意味着每个分片包含了所有的文档属性，但包含的 JSON 对象数量少于索引。水平分离使分片成为一个独立的节点，且可以存储在任何节点，主分片是索引的原始水平部分，然后将这些主分片复制到副本分片中。</li>
<li>副本：es允许用户创建索引和分片的副本。复制不仅有助于在发生故障时提高数据的可用性，而且通过在这些副本中执行并行搜索操作来提高搜索性能。</li>
</ul>
<h2 id="5-es的优势"><a href="#5-es的优势" class="headerlink" title="5. es的优势"></a>5. es的优势</h2><ul>
<li>es 是基于 Java 开发的，这使得它几乎可以兼容所有平台；</li>
<li>es 是实时的，也就是说一秒后添加的文档就可以在这个引擎中搜索了；</li>
<li>es 是分布式的，这使得它可以轻松地在任何大型组织中扩展和集成。</li>
<li>使用 es 中的网关概念可以轻松创建完整备份。</li>
<li>与 Apache Solr 相比，在 es 中处理多租户非常容易。</li>
<li>es 使用 JSON 对象作为响应，这使得使用大量不同的编程语言调用 es 服务器成为可能。</li>
<li>es 支持几乎所有文档类型，除了那些不支持文本渲染的文档类型。</li>
</ul>
<h2 id="6-es的缺点"><a href="#6-es的缺点" class="headerlink" title="6. es的缺点"></a>6. es的缺点</h2><ul>
<li>与 Apache Solr 不同，es 在处理请求和响应数据方面没有多语言支持（仅支持JSON），而Apache Solr 可以支持 CSV、XML 和 JSON 格式。</li>
<li>偶尔，es 会出现**<em>脑裂（Split brain）**</em>的问题。（什么是脑裂）</li>
</ul>
<h2 id="7-es和关系数据库之间的区别"><a href="#7-es和关系数据库之间的区别" class="headerlink" title="7. es和关系数据库之间的区别"></a>7. es和关系数据库之间的区别</h2><p>在 es 中，索引类似于 RDBMS（关系数据库管理系统）中的表。 每个表都是行的集合，就像 es 中的每个索引都是文档的集合一样。<br>下表给出了这些术语之间的直接比较 -</p>
<table>
<thead>
<tr>
<th>es</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>集群</td>
<td>数据库</td>
</tr>
<tr>
<td>分片</td>
<td>分片</td>
</tr>
<tr>
<td>索引</td>
<td>表</td>
</tr>
<tr>
<td>字段</td>
<td>列</td>
</tr>
<tr>
<td>文档</td>
<td>行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>java</tag>
        <tag>分布式</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>在manjaro中修复deepin-wine-wechat对话框输入中文乱码的问题</title>
    <url>/2021/10/26/fix-chinese-luan-ma-in-deepin-wine-wechat/</url>
    <content><![CDATA[<h2 id="最近在manjaro上安装了deepin-wine-wechat，毕竟生活中用微信还是挺多的，但腾讯貌似短期内并没有将微信移植到linux桌面平台的打算，所以，作为替代方案，只能使用deepin基于wine定制的微信客户端"><a href="#最近在manjaro上安装了deepin-wine-wechat，毕竟生活中用微信还是挺多的，但腾讯貌似短期内并没有将微信移植到linux桌面平台的打算，所以，作为替代方案，只能使用deepin基于wine定制的微信客户端" class="headerlink" title="最近在manjaro上安装了deepin-wine-wechat，毕竟生活中用微信还是挺多的，但腾讯貌似短期内并没有将微信移植到linux桌面平台的打算，所以，作为替代方案，只能使用deepin基于wine定制的微信客户端"></a>最近在manjaro上安装了deepin-wine-wechat，毕竟生活中用微信还是挺多的，但腾讯貌似短期内并没有将微信移植到linux桌面平台的打算，所以，作为替代方案，只能使用deepin基于wine定制的微信客户端</h2><p>首先GNU/Linux操作系统作为一款世界流行的操作系统，其稳定性和可定制性都是非常优秀的。但由于众多linux发行版大部分都是从国外发展起来的，虽然近几年来国内也有几家比较优秀的linux厂商，但终究起步别别人晚，所以还是有很多需要提升的地方。对于打着国产操作系统旗号的Deepin团队而言，想要在国内推广他们定制的Deepin Linux发行版，首先在通讯软件方面就要能够提供最常用的几款即时通讯软件的移植版，毕竟国内通讯软件市场还是腾讯一家独大，奈何鹅厂迟迟不将linux平台的QQ、微信的开发提上日程，而目前能够最大限度移植Windows程序到linux上执行的莫过于使用Wine了。所以，基于Wine提供linux版的微信和QQ也成为了最为方便快捷的选择。</p>
<p>这次安装完deepin-wine-wechat之后，正常启动没问题，但当我打开和好友聊天的对话框时发现我输入的中文在内容栏里面都变成了一个个空心的小方块。但当我将消息发送出去之后，我的消息又变成了正常的中文。经过查找资料后发现，是因为wine模拟的windows环境里面缺少了宋体的字体文件，所以，只需要将宋体文件复制到对应的字体目录下就可以了。步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.下载宋体字符集文件：https://www.freefonts.io/downloads/simsun/</span><br><span class="line">2.将解压后的文件复制如下路径：cp ~/Downloads/SIMSUN.ttf ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts/</span><br><span class="line">3.重启微信即可解决。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>问题修复</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>FormattingConversionService类的使用</title>
    <url>/2021/01/10/formattingConversionService/</url>
    <content><![CDATA[<h2 id="它是什么"><a href="#它是什么" class="headerlink" title="它是什么"></a>它是什么</h2><p>Spring MVC框架中用来解析方法参数的service类。</p>
<h2 id="它有什么用"><a href="#它有什么用" class="headerlink" title="它有什么用"></a>它有什么用</h2><p>当我们在Spring的配置文件中添加<code><mvc:annotation-driven /></code>时，如果我们没有明确指定<code>conversion-service</code>属性的值，那么Spring MVC框架会自动使用默认的FormattingConversionService类，它包含了常用的转换方法，将字段转换成标准的JDK类型，另外，如果我们需要<code>date/time</code>的转换器，可以在类路径下引入<code>Joda Time</code>的时间库，它会被默认识别。</p>
<h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><p>如果我们不需要在字段绑定期间使用自定义的类型转换器，那么我们完全可以使用默认的类。</p>
<p>如果我们需要自定义格式转换器类的话，我们可以继承该类，并将<code><mvc:annotation /></code>注解中<code>conversion-service</code>属性的值设为我们自己的类（使用类路径引入）。</p>
<p>如果使用的是SpringBoot自动装配的话，则需要在自定义的类上加上<code>@Configuration</code>注解，并使用<code>DateTimeFormatterRegistrar</code>注册器注册我们自定义的日期解析器。然后使用<code>@Autowired</code>添加到Spring容器中。</p>
]]></content>
      <categories>
        <category>spring原理</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>util</tag>
      </tags>
  </entry>
  <entry>
    <title>linux上的实用软件清单（个人用）</title>
    <url>/2021/03/16/great-tool-for-linux/</url>
    <content><![CDATA[<h2 id="为什么要列这个清单"><a href="#为什么要列这个清单" class="headerlink" title="为什么要列这个清单"></a>为什么要列这个清单</h2><p>在使用gnu linux（后面均简称为linux）操作系统的过程当中，总有一些软件让你觉得即使没有windows也能让自己的工作和生活变得更加便利，因此，为了方便后面因为更换发行版或者因为不可控因素导致系统损坏而必须重新安装linux系统，特别将自己平时用的比较多的软件列出来以供后面安装新系统之后能够快速恢复到正常工作和生活状态。个人觉得，对于linux用户来说，相对于windows系统中软件来源的不可控性和零散性，linux系统自带的包管理器绝对是节约我们软件安装时间的一大利器。而且更便于自动化安装和初始化，而作为软件开发者，良好的编程环境更是完胜windows系统。也希望这个清单能让自己在今后的软件开发生涯中更加注重时间的重要性，不要浪费时间在一些无意义的折腾上，毕竟，系统是拿来用的，高效才是操作系统带给我们最终的目的。</p>
<blockquote>
<p><strong>以下包管理器均采用archlinux内置的<code>pacman</code></strong></p>
</blockquote>
<h2 id="翻译类软件"><a href="#翻译类软件" class="headerlink" title="翻译类软件"></a>翻译类软件</h2><ol>
<li>带gui的：goldendict、stardict（星际译王）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S goldendict</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo pacman -S stardict</span><br></pre></td></tr></table></figure>
<a href="http://download.huzheng.org/zh_CN/">字典下载链接</a><span id="more"></span></li>
<li>不带gui的：dictd（可以离线使用），translate-shell（必须连上网络）</li>
</ol>
<ul>
<li><strong>dictd</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S dictd dict</span><br></pre></td></tr></table></figure>
dict是客户端，dictd是dict的后台服务器。默认安装之后是不带任何字典的，使用网络查询，且只能查询到英文释义。如果想要支持中文字典的话得自行下载对应的词库，但目前来说官网并不提供中文字典，需要自行将goldendict的字典文件转换成dictd可识别的文件格式。<br>目前个人使用的开源转换工具是<a href="https://github.com/ilius/pyglossary">pyglossary</a>，该工具使用python编写，支持的格式也比较多，从github上下载到安装文件之后，需要使用pip工具进行安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装pip工具</span></span><br><span class="line">sudo pacman -S python-pip</span><br><span class="line">sudo pip install pyglossary-x.x.x-py3-none-any.whl</span><br></pre></td></tr></table></figure>
安装完成之后在终端中输入pyglossary启动工具，并在输入文件时选择goldendict的词典文件（一般是以<code>.ifo</code>后缀名结尾。然后输出文件选择以<code>.index</code>作为后缀的文件类型，点击Convert按钮之前记住将<code>/usr/share/dictd</code>的目录权限授予当前用户，否则无法自动复制过去，且控制台会报错。<br><a href="https://www.jianguoyun.com/p/DYQBDsEQiZ6nCRiKr-cD">自用</a></li>
<li><strong>translate-shell</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S translate-shell</span><br></pre></td></tr></table></figure>
该命令行软件的强大之处在于它集成了目前可用的几大翻译软件，如google翻译、bing翻译（百度翻译待求证）<br>安装完之后，使用如下命令即可翻译英文单词或者句子<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 翻译单词（英译汉）</span></span><br><span class="line">trans -s en -t zh like</span><br><span class="line"><span class="comment"># -s en 代表输入的语言类型，-t zh 代表输出的语言类型</span></span><br><span class="line"><span class="comment"># 翻译句子</span></span><br><span class="line">trans -s en -t zh <span class="string">&quot;i love you&quot;</span></span><br></pre></td></tr></table></figure>
或者进入交互模式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trans -s en -t zh -shell -brief</span><br></pre></td></tr></table></figure>
使用<code>:q</code>退出</li>
</ul>
<h2 id="翻墙类软件"><a href="#翻墙类软件" class="headerlink" title="翻墙类软件"></a>翻墙类软件</h2><ol>
<li>带gui的：qv2ray、v2ray desktop、v2rayA（web管理界面）</li>
</ol>
<ul>
<li>qv2ray<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qv2ray</span><br></pre></td></tr></table></figure>
该工具只支持基于v2ray内核的传输协议，如vmess，不支持shadowsocks协议；</li>
<li>v2ray desktop<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要想使用下面的命令安装该软件，需要配置archlinuxcn的软件源或者使用aur包管理器，比如yay。</span></span><br><span class="line">sudo pacman -S v2ray-desktop</span><br></pre></td></tr></table></figure>
该工具支持shadowsocks协议和基于v2ray内核的vmess协议，而且支持订阅，比较方便，但没有导出功能。相对于qv2ray来说，功能稍显简单，但好在支持的协议比较丰富。</li>
<li>v2rayA<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S v2raya</span><br></pre></td></tr></table></figure>
该工具的强大之处在于支持的协议更多，而且配置简单，支持订阅以及透明代理（比系统代理更加强大，可以代理全局流量）。另外，它的安装包形式也很多样，除了使用系统自带的包管理器安装之外，还支持docker安装、appImage安装。具体配置见github官网。<a href="https://github.com/v2rayA/v2rayA">v2raya源码以及使用手册</a></li>
</ul>
<ol start="2">
<li>不带gui的：mellow</li>
</ol>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>gzip操作手册</title>
    <url>/2021/03/13/gzip-manual/</url>
    <content><![CDATA[<h2 id="gzip工具"><a href="#gzip工具" class="headerlink" title="gzip工具"></a>gzip工具</h2><p>gzip采用了最流行的压缩算法，可以让你缩小文件的大小，并且保留原始的文件模式，属主和时间戳。<br>使用gzip工具压缩的文件一般使用.gz的文件名后缀，并且gzip也可以用来解压缩文件。</p>
<h2 id="命令格式以及说明"><a href="#命令格式以及说明" class="headerlink" title="命令格式以及说明"></a>命令格式以及说明</h2><p>通常的语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip [可选项] ... [文件]...</span><br></pre></td></tr></table></figure>
<p>gzip只能压缩单个文件，并为给定的文件创建一个压缩之后的文件。根据惯例，压缩之后的文件的命令一把使用<code>.gz</code>或者<code>.z</code>。<br>如果你想将多个文件或者目录压缩到一个文件中，首先你需要创建一个tar包，然后对这个tar包进行压缩。这样的文件一般会使用<code>.tar.gz</code>或者<code>.tgz</code>作为后缀来表明这个文件是使用了gzip压缩之后的tar包。<br>gzip最常用作压缩文本文件，tar包或者网页，尽量不要使用gzip去压缩图片，音频，pdf文档或者其他的二进制文件，因为他们已经被压缩过了。<br>gzip只能压缩常规文件，符号链接文件会被忽略。</p>
<h2 id="使用gzip压缩文件"><a href="#使用gzip压缩文件" class="headerlink" title="使用gzip压缩文件"></a>使用gzip压缩文件</h2><ul>
<li>不带任何参数的压缩<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip 你的文件</span><br></pre></td></tr></table></figure>
该命令将会创建一个<code>你的文件.gz</code>文件，然后删除原始文件。<br>默认情况下，gzip会保留原始文件的时间戳，模式，属主和文件名。</li>
<li>保留原始文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -k 你的文件</span><br></pre></td></tr></table></figure>
另外一种保留原始文件的方法是使用<code>-c</code>选项，告诉gzip将原始文件写入到标准输出，然后重定向到指定的文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -c 你的文件 &gt; 你的文件.gz</span><br></pre></td></tr></table></figure></li>
<li>查看冗余信息<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -v 你的文件</span><br></pre></td></tr></table></figure>
该命令将会输出压缩进度信息</li>
<li>压缩多个文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip 文件1 文件2 文件3</span><br></pre></td></tr></table></figure>
该命令将会生成<code>文件1.gz</code>、<code>文件2.gz</code>、<code>文件3.gz</code>这3个文件。</li>
<li>压缩目录<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -r 你的目录</span><br></pre></td></tr></table></figure>
该命令会递归压缩你的目录下的所有文件，分别生成<code>.gz</code>文件。</li>
<li>改变压缩等级<br>gzip允许我们指定文件的压缩等级，范围是1-9，而<code>-1</code>或者<code>--fast</code>则代表使用最小的压缩率以达到最快的压缩速度；而<code>-9</code>或者<code>--best</code>则代表使用最高的压缩率，相应的，也会有最慢的压缩速度。默认的压缩级别是6；<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -9 你的文件</span><br></pre></td></tr></table></figure>
压缩是CPU密集型的任务，压缩等级越高，压缩过程越长。</li>
<li>使用标准输入<br>为了从标准输入创建<code>.gz</code>文件，使用管道命令重定向到gzip。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump database_name | gzip -c &gt; database_name.sql.gz</span><br></pre></td></tr></table></figure>
该命令将会把<code>mysqldump</code>的输出内容作为输入传递给gzip。</li>
</ul>
<h2 id="使用gzip解压缩"><a href="#使用gzip解压缩" class="headerlink" title="使用gzip解压缩"></a>使用gzip解压缩</h2><ul>
<li>使用-d作为解压缩选项<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -d 你的文件.gz</span><br></pre></td></tr></table></figure>
另一个可以用于解压缩的命令是gunzip，它可以算作是gzip -d的别名。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gunzip 你的文件.gz</span><br></pre></td></tr></table></figure></li>
<li>保留原始压缩文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -dk 你的文件.gz</span><br></pre></td></tr></table></figure></li>
<li>解压缩多个文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -d 你的文件1.gz 你的文件2.gz 你的文件3.gz</span><br></pre></td></tr></table></figure></li>
<li>解压缩目录下的所有压缩文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -dr 你的目录</span><br></pre></td></tr></table></figure></li>
<li>查看压缩文件的内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -l 你的文件</span><br></pre></td></tr></table></figure>
使用<code>-v</code>可以得到更加详细的信息。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title>在linux系统终端查看硬件信息</title>
    <url>/2021/10/05/hardware-info-cmd/</url>
    <content><![CDATA[<h2 id="使用如下命令查看包括CPU、内存、硬盘、主板在内的各种硬件相关的信息"><a href="#使用如下命令查看包括CPU、内存、硬盘、主板在内的各种硬件相关的信息" class="headerlink" title="使用如下命令查看包括CPU、内存、硬盘、主板在内的各种硬件相关的信息"></a>使用如下命令查看包括CPU、内存、硬盘、主板在内的各种硬件相关的信息</h2><ul>
<li><p>CPU型号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;model name&quot;</span> | uniq</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看CPU物理个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span> | uniq | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装工具软件，以archlinux为例</span></span><br><span class="line">sudo pacman -S dmidecode</span><br><span class="line">sudo dmidecode -t memory | grep Size</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存条厂家</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dmidecode -t memory | grep Manufacturer</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看硬盘信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l | grep <span class="string">&quot;Disk /dev/sd&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看主板信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dmidecode | grep -A16 <span class="string">&quot;System Information$&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么在不开机的情况下让树莓派自动连接上wifi</title>
    <url>/2021/09/26/how-raspberry-pi-connect-to-wifi-without-boot/</url>
    <content><![CDATA[<p><img src="/assets/raspberry_pi.jpg" alt="树莓派"></p>
<h2 id="什么是树莓派"><a href="#什么是树莓派" class="headerlink" title="什么是树莓派"></a>什么是树莓派</h2><p>树莓派（Raspberry Pi）是一款只有巴掌大小的微型计算机开发板，别看它体积小，但它确实是一个功能完备的计算机，可以做绝大部分我们个人电脑（PC）可以做的事情。而且功耗更小。</p>
<h2 id="树莓派支持的系统"><a href="#树莓派支持的系统" class="headerlink" title="树莓派支持的系统"></a>树莓派支持的系统</h2><p>目前除了官方主推的Raspberry Pi OS ，还有其他第三方系统，比如基于ubuntu和debian的arm发行版，理论上可以安装微软的Windows，但不推荐，毕竟Windows是收费软件，而且对系统资源相较于linux有更高的要求，作为一款主打轻量级的开发版，Windows显然太重了。</p>
<h2 id="树莓派怎么联网"><a href="#树莓派怎么联网" class="headerlink" title="树莓派怎么联网"></a>树莓派怎么联网</h2><ol>
<li>树莓派自带支持802.11n的以太网网卡，因此可以直接使用支持RJ45的标准网口连接上网；</li>
<li>从Model 3开始，树莓派自带支持802.11n的无线网卡，对于无法通过网线直连的场合，wifi变成了我们唯一的途径。</li>
</ol>
<p>下面具体就怎么在不开机的情况下配置无线连接做个介绍，方便大家在无线环境中使用树莓派。</p>
<blockquote>
<p>不得不说，树莓派自带的无线网卡的性能确实很弱，对于大流量的场景不推荐使用，最好自备外接无线网卡。</p>
</blockquote>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><p>本教程基于Raspberry Pi OS，其他发行版系统可能不适用。下载地址：<a href="https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2021-05-28/2021-05-07-raspios-buster-armhf.zip%E3%80%82">https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2021-05-28/2021-05-07-raspios-buster-armhf.zip。</a></p>
<h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>在linux下面可以使用如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/home/your_home/raspberryOS.iso of=/dev/sd&#123;x&#125; bs=4MB status=progress</span><br></pre></td></tr></table></figure>

<p>注意，使用上面的命令时必须确保of参数对应的值是你要写入的SD卡，一般以sd开头，if参数对应的是你下载解压后的原始镜像地址。</p>
<blockquote>
<p>windows上的启动盘制作请自行百度</p>
</blockquote>
<h3 id="写入wifi配置"><a href="#写入wifi配置" class="headerlink" title="写入wifi配置"></a>写入wifi配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">country=CN <span class="comment">#这里是我们位于的国家的缩写</span></span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1 <span class="comment">#更新现有配置</span></span><br><span class="line">network=&#123;</span><br><span class="line">  ssid=<span class="string">&quot;你的wifi名称&quot;</span></span><br><span class="line">  scan_ssid=1</span><br><span class="line">  psk=<span class="string">&quot;你的wifi密码&quot;</span></span><br><span class="line">  key_mgmt=WPA-PSK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将该文件命名为<code>wpa_supplicant.conf</code>，并将其保存到制作好的启动盘的最外层的boot目录下。</p>
<h3 id="允许ssh访问"><a href="#允许ssh访问" class="headerlink" title="允许ssh访问"></a>允许ssh访问</h3><p>在启动盘的最外层的boot目录下创建ssh文件，不需要向里面写入内容。</p>
<p><strong>最后将制作好的sd卡插入到树莓派中启动即可自动连接wifi,然后我们在路由器管理页面查看已连接设备中就能看到带有raspberry pi标签的设备了，找出其ip地址，尝试下使用ssh连接并管理树莓派，如果一切顺利的话，你将可以通过远程访问来管理你的树莓派设备了。</strong></p>
<h2 id="使用静态ip地址"><a href="#使用静态ip地址" class="headerlink" title="使用静态ip地址"></a>使用静态ip地址</h2><p>由于树莓派内置了DHCP服务，所以，当我们每次连接上wifi时可能会被分配到不同的ip地址，这显然不利于配置外部对于树莓派后台服务的访问，因此，我们在连接上wifi之后，可以给树莓派配置一个静态ip。</p>
<p>打开<code>/etc/dhcpcd.conf</code>文件，向里面追加如下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface wlan0</span><br><span class="line">static ip_address=192.168.0.193/24</span><br><span class="line">static routers=192.168.0.1</span><br><span class="line">static domain_name_servers=192.168.0.1 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>其中<code>wlan0</code>是我们无线网卡的系统名称，后面的<code>ip_address</code>则是我们自定义的ip地址，<code>routers</code>是我们的路由，<code>domain_name_server</code>是我们的DNS地址，多个DNS的场合使用空格隔开。</p>
]]></content>
      <categories>
        <category>raspberry pi</category>
      </categories>
      <tags>
        <tag>raspberry pi</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>在gnome桌面环境下设置默认文件管理器</title>
    <url>/2021/10/20/how-to-set-default-file-manager-for-gnome/</url>
    <content><![CDATA[<h3 id="gnome桌面设置工具中默认无法设置默认的文件管理器，所以，当我们在kde桌面环境下设置了dolphin为文件管理器之后，重新切回到gnome之后会发现dolphin仍然是默认的文件管理器，所以，我们需要将gnome桌面默认的Nautilus文件管理器重新设为默认值，以下命令可以帮助我们做到这一点："><a href="#gnome桌面设置工具中默认无法设置默认的文件管理器，所以，当我们在kde桌面环境下设置了dolphin为文件管理器之后，重新切回到gnome之后会发现dolphin仍然是默认的文件管理器，所以，我们需要将gnome桌面默认的Nautilus文件管理器重新设为默认值，以下命令可以帮助我们做到这一点：" class="headerlink" title="gnome桌面设置工具中默认无法设置默认的文件管理器，所以，当我们在kde桌面环境下设置了dolphin为文件管理器之后，重新切回到gnome之后会发现dolphin仍然是默认的文件管理器，所以，我们需要将gnome桌面默认的Nautilus文件管理器重新设为默认值，以下命令可以帮助我们做到这一点："></a>gnome桌面设置工具中默认无法设置默认的文件管理器，所以，当我们在kde桌面环境下设置了dolphin为文件管理器之后，重新切回到gnome之后会发现dolphin仍然是默认的文件管理器，所以，我们需要将gnome桌面默认的Nautilus文件管理器重新设为默认值，以下命令可以帮助我们做到这一点：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xdg-mime default org.gnome.Nautilus.desktop inode/directory</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述命令会修改<code>~/.config/mimeapps.list</code>的内容，具体内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inode/directory=org.gnome.Nautilus.desktop</span><br></pre></td></tr></table></figure>

<p>分别对应<code>[Default Applications]</code>和<code>[Added Associations]</code>目录。</p>
</blockquote>
]]></content>
      <categories>
        <category>gnome</category>
      </categories>
      <tags>
        <tag>默认文件管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何vps上搭建自己的git服务器</title>
    <url>/2020/12/29/how-to-set-up-a-private-git-server-on-your-vps/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>面试指南</title>
    <url>/2021/10/07/interview-guide/</url>
    <content><![CDATA[<h2 id="1、说下你的优点和缺点"><a href="#1、说下你的优点和缺点" class="headerlink" title="1、说下你的优点和缺点"></a>1、说下你的优点和缺点</h2><ul>
<li><p>缺点：</p>
<p>公开演讲</p>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>java知识点速记</title>
    <url>/2021/01/07/java-point/</url>
    <content><![CDATA[<h2 id="java-bean和pojo的区别"><a href="#java-bean和pojo的区别" class="headerlink" title="java bean和pojo的区别"></a>java bean和pojo的区别</h2><p>一、 定义</p>
<ul>
<li><p><code>POJO</code>是<code>Plain Old Java Object</code>的缩写，它主要用来强调某个对象是一个普通的Java对象，而不是一个特殊的对象，尤其不是一个EJB。</p>
<p>这个术语以其简单易懂的特性被广泛接受并使用，并用来区别那些复杂的对象框架。</p>
</li>
<li><p>一个<code>JavaBean</code>是一个可以被序列化的<code>POJO</code>。有一个默认的无参构造器，并允许使用Getter和Setter方法访问属性。</p>
<p>对于EJB来说，<code>JavaBean</code>并不是一个单独的类，而是整个组件模型。</p>
<p>JavaBean是java构建程序中可重用的软件组件，实际开发过程中，它们是使用java语言编写并符合某个约定的类。它们被用来封装一些对象到单个对象（也就是bean）中。</p>
</li>
</ul>
<p>二、 用法</p>
<ul>
<li><code>POJO</code>主要被用来表明一个java对象不需要跟随任何java对象模型、约定或者框架。最理想的情况，一个<code>POJO</code>应该是一个不和任何框架绑定的java对象，并遵循以下原则：<ol>
<li>不应该继承某个指定的类，比如HttpServlet；</li>
<li>不应该实现指定的接口，比如EntityBean；</li>
<li>不应该包含某些框架的注解。</li>
</ol>
</li>
<li>JavaBean应该遵循以下原则：<ol>
<li>必须有一个公共的默认构造器，便于实例化；</li>
<li>属性必须可以通过Getter和Setter或者其他的可以访问并修改的方法进行控制，并遵循标准的命名规范，以便于框架对其进行自动化管理和状态的更新；</li>
<li>必须可以被序列化，以便于应用和框架以一种独立于VM和操作系统的方式对其进行可靠的保存、存储以及恢复bean的状态。</li>
</ol>
</li>
</ul>
<p>对于业务程序员来说，这两种类型的java对象其实可以等同，或者说POJO更多强调的是一种业务概念，而JavaBean则属于java编程语言的特性。</p>
]]></content>
      <categories>
        <category>java学习笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins学习笔记</title>
    <url>/2021/03/30/jenkins-study-notes/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp-tag-usage-1</title>
    <url>/2021/01/08/jsp-tag-usage-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>mybatis原理学习笔记</title>
    <url>/2021/01/04/mybatis-theory-interview/</url>
    <content><![CDATA[<h2 id="mybatis的执行原理："><a href="#mybatis的执行原理：" class="headerlink" title="mybatis的执行原理："></a>mybatis的执行原理：</h2><p>通常一个Mapper接口对应一个xml文件，Mapper接口中的方法名对应xml中的标签id，而xml中的每一个标签都会被解析为MapperStatement对象。通过xml中定义的namespace属性，可以和接口方法的执行路径相对应。而这个路径应该具有唯一性，<strong>所以Mapper接口中的方法不能被重载</strong>。Mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql语句，然后将执行结果返回。</p>
<h2 id="mybatis的分页原理："><a href="#mybatis的分页原理：" class="headerlink" title="mybatis的分页原理："></a>mybatis的分页原理：</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内容分页，而非物理分页。</p>
<h2 id="mybatis-pagehelper插件的实现原理："><a href="#mybatis-pagehelper插件的实现原理：" class="headerlink" title="mybatis-pagehelper插件的实现原理："></a>mybatis-pagehelper插件的实现原理：</h2><p>使用mybatis提供的插件接口，实现自定义插件，在插件内拦截待执行的sql,然后重写sql,根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>nmap命令使用教程</title>
    <url>/2021/08/08/namp-command-tutorial/</url>
    <content><![CDATA[<ol>
<li><p>扫描单个目标地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描多个目标地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100 192.168.0.105</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描一个范围内的目标地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100-200</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描目标地址所在的某个网段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描主机列表targets.txt文件中的所有目标地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -iL ~/targets.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描除某一个目标地址之外的所有目标地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100/24 -exclude 192.168.0.105</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描除某一文件中的目标地址之外的目标地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100/24 -exceludefile ~/targets.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描某一目标地址的21、22、23、80端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.100 -p 21,22,23,80</span><br></pre></td></tr></table></figure>
</li>
<li><p>对目标地址进行路由跟踪</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --traceroute 192.168.0.100</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描目标地址所在C段的在线状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sP 192.168.0.100/24</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标地址的操作系统指纹识别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.0.100</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标地址提供的服务版本检测</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.0.105</span><br></pre></td></tr></table></figure>
</li>
<li><p>探测防火墙状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sF -T4 192.168.0.100</span><br></pre></td></tr></table></figure>





























</li>
</ol>
]]></content>
      <categories>
        <category>nmap</category>
      </categories>
      <tags>
        <tag>nmap</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>netty高性能web服务器介绍</title>
    <url>/2021/01/09/netty-intro/</url>
    <content><![CDATA[<h2 id="1-什么是netty"><a href="#1-什么是netty" class="headerlink" title="1. 什么是netty"></a>1. 什么是netty</h2><p>Netty是一个异步的事件驱动网络应用框架。</p>
<p>它的主要用途是构建高性能协议服务器，并通过基于隔离和松耦合的网络和业务逻辑组件的NIO（非阻塞输入输出）技术实现这一点。它可以实现广为人知的Http协议或者我们自定义的协议。</p>
<h2 id="2-netty的核心概念"><a href="#2-netty的核心概念" class="headerlink" title="2. netty的核心概念"></a>2. netty的核心概念</h2><p>netty是一个非阻塞式框架，和阻塞式IO相比，它拥有更高的吞吐量。理解非阻塞式IO是掌握Netty的核心组件以及他们之间的关系的关键所在。</p>
<h3 id="2-1-Channel（通道）"><a href="#2-1-Channel（通道）" class="headerlink" title="2.1 Channel（通道）"></a>2.1 Channel（通道）</h3><p>Channel是NIO的基石，它代表了一个拥有IO（读和写）处理能力的开放连接。</p>
<h3 id="2-2-Future"><a href="#2-2-Future" class="headerlink" title="2.2 Future"></a>2.2 Future</h3><p><strong>对于Netty来说，Channel中的每一个连接都是非阻塞的。</strong></p>
<p>这意味着每个操作在调用之后都会立刻返回。标准Java库中有一个Future的接口，但是它并不能方便的完成Netty的意图，因为我们只能通过这个接口去查询操作是否已完成或者阻塞当前线程直到操作完成。</p>
<p>基于上面的原因，Netty实现了自己的ChannelFuture接口。我们可以通过回调函数告诉ChannelFuture，一旦操作完成，将要执行的操作。</p>
<h3 id="2-3-事件和处理器"><a href="#2-3-事件和处理器" class="headerlink" title="2.3 事件和处理器"></a>2.3 事件和处理器</h3><p>Netty使用了基于事件驱动的应用模式，因此数据处理的管道（pipeline）本质上是贯穿处理器（handler）的一连串事件的链（chain）。事件和处理器类似于数据的流入以及流出。流入事件可以是下面的几种：</p>
<ul>
<li>通道的激活和失活</li>
<li>读事件</li>
<li>异常事件</li>
<li>用户事件</li>
</ul>
<p>流出事件则比较简单，一般类似于打开或者关闭连接以及写入数据。</p>
<p>Netty应用包含了几个网络和应用的逻辑事件以及他们对应的处理器。channel事件处理器可以使用的基础接口分别是ChannelHandler和它的祖先ChannelOutboundHandler和ChannelInboundHandler。</p>
<p>Netty提供了大量的ChannelHandler接口的实现类。值得注意的是，适配器只是空的实现，例如ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter。我们可以继承这些适配器当我们只需要处理所有事件集合中的子集。</p>
<p>同样，Netty包含了某些指定协议的具体实现，比如Http。HttpRequestDecoder，HttpResponseEncoder，HttpObjectAggregator。你可以通过Netty的javaDoc去了解他们的用法。</p>
<h3 id="2-4-编码器和解码器"><a href="#2-4-编码器和解码器" class="headerlink" title="2.4 编码器和解码器"></a>2.4 编码器和解码器</h3><p>当我们使用网络协议时，我们需要对数据进行序列化和反序列化。出于这个目的，Netty引进了一个特殊的解码拓展类ChannelInboundHandler，它可以对进来的数据进行解码。大多数解码器的基类是ByteToMessageDecoder。</p>
<p>为了编码出去的数据，Netty也提供了一个特殊的编码实现类ChannelOutboundHandler。MessageToByteEncoder是大多数编码实现类的基类。通过编码器和解码器，我们可以将信息从字节序列转换成java对象，反之亦然。</p>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>php——使用pdo连接mysql数据库</title>
    <url>/2021/08/10/php-connect-mysql-with-pdo/</url>
    <content><![CDATA[<h2 id="PDO是什么"><a href="#PDO是什么" class="headerlink" title="PDO是什么"></a>PDO是什么</h2><p>PDO（PHP Data Objects）拓展是一个轻量级、而且统一的接口，用来在PHP中访问数据库。</p>
<p>PDO提供了一个数据访问抽象层，这意味着，不管你使用的是什么数据库，你都可以使用相同的函数去执行查询并获取数据。</p>
<p>PDO不提供数据库抽象，无法消除不同数据库之间的语法差异，如果你想要做到做到这一点，你必须使用另外的抽象层去实现。</p>
<h2 id="PDO连接MySQL数据库"><a href="#PDO连接MySQL数据库" class="headerlink" title="PDO连接MySQL数据库"></a>PDO连接MySQL数据库</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库主机地址</span></span><br><span class="line"><span class="keyword">const</span> DB_HOST = <span class="string">&#x27;mysqldb&#x27;</span>;</span><br><span class="line"><span class="comment">// 数据库名称</span></span><br><span class="line"><span class="keyword">const</span> DB_NAME = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="comment">// 数据库用户名</span></span><br><span class="line"><span class="keyword">const</span> DB_USER = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">// 数据库密码</span></span><br><span class="line"><span class="keyword">const</span> DB_PASSWORD = <span class="string">&#x27;devstack&#x27;</span>;</span><br><span class="line"><span class="comment">// 连接对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="variable">$pdo</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 格式化连接字符串</span></span><br><span class="line"><span class="variable">$conStr</span> =  sprintf(<span class="string">&quot;mysql:host=%s;dbname=%s&quot;</span>, <span class="built_in">self</span>::DB_HOST, <span class="built_in">self</span>::DB_NAME);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">$this</span> -&gt; pdo = <span class="keyword">new</span> PDO(<span class="variable">$conStr</span>, <span class="built_in">self</span>::DB_USER, <span class="built_in">self</span>::DB_PASSWORD);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PDOException <span class="variable">$e</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$e</span> -&gt; getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用pdo连接对象执行插入、更新或者删除"><a href="#使用pdo连接对象执行插入、更新或者删除" class="headerlink" title="使用pdo连接对象执行插入、更新或者删除"></a>使用pdo连接对象执行插入、更新或者删除</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;insert into tasks (subject, start_date, end_date, description)</span></span><br><span class="line"><span class="string">                    values (&#x27;%s&#x27;, &#x27;%s&#x27;, &#x27;%s&#x27;, &#x27;%s&#x27;);&quot;</span>;</span><br><span class="line"><span class="variable">$insertStatement</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 构造插入语句</span></span><br><span class="line"><span class="comment">// date(&quot;Y-m-d H:i:s&quot;)的输出格式为yyyy-mm-dd hh:mm:ss</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">10</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$insertStatement</span> .= sprintf(<span class="variable">$sql</span>, <span class="string">&quot;睡觉&quot;</span>, date(<span class="string">&quot;Y-m-d H:i:s&quot;</span>), date(<span class="string">&quot;Y-m-d H:i:s&quot;</span>), <span class="string">&quot;测试&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用exec方法执行插入</span></span><br><span class="line"><span class="keyword">$this</span> -&gt; pdo -&gt; exec(<span class="variable">$insertStatement</span>);</span><br><span class="line"><span class="comment">// 更新和删除都可以使用exec()，返回值为表的影响条数</span></span><br></pre></td></tr></table></figure>

<h2 id="使用pdo连接对象执行查询"><a href="#使用pdo连接对象执行查询" class="headerlink" title="使用pdo连接对象执行查询"></a>使用pdo连接对象执行查询</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from tasks&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">$this</span> -&gt; pdo -&gt; query(<span class="variable">$sql</span>) <span class="keyword">as</span> <span class="variable">$row</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$row</span>[<span class="string">&#x27;subject&#x27;</span>] . <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$row</span>[<span class="string">&#x27;start_date&#x27;</span>] . <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$row</span>[<span class="string">&#x27;end_date&#x27;</span>] . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用query方法可以执行查询操作。通过<code>foreach</code>遍历查询结果。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>pdo</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>redis命令学习</title>
    <url>/2021/01/03/redis-commander-study/</url>
    <content><![CDATA[<h2 id="redis存储string类型的值"><a href="#redis存储string类型的值" class="headerlink" title="redis存储string类型的值"></a>redis存储string类型的值</h2><ol>
<li><p>存值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>取值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回key中的部分字符串:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getrange key start end</span><br></pre></td></tr></table></figure>

<div class="note info"><p>start从0开始，且返回的内容中包含索引为end的字符。</p>
</div>
</li>
<li><p>取出旧值并返回新值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getset key new_value</span><br></pre></td></tr></table></figure>
</li>
<li><p>取出key对应的值，并返回指定偏移量上的位(bit)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getbit key offset</span><br></pre></td></tr></table></figure>
</li>
<li><p>一次性取出多个值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mget key1 key2 ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>当key不存在时才设值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setnx key value</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回给定key的超时时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看key的类型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> key</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="redis系统管理命令"><a href="#redis系统管理命令" class="headerlink" title="redis系统管理命令"></a>redis系统管理命令</h2><ol>
<li>给redis服务器设置密码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass my_password</span><br><span class="line"><span class="comment"># 获取密码</span></span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line"><span class="comment"># 使用设置过的密码登陆</span></span><br><span class="line">127.0.0.1:6379&gt; auth my_password</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1)<span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2)<span class="string">&quot;my_password&quot;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面的设置方式在redis服务器重启之后便会失效，如果需要重启后仍然有效，则可以修改配置文件</p>
<p>打开<code>/etc/redis/redis.conf</code>，修改如下地方：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># requirepass foobared</span></span><br></pre></td></tr></table></figure>

<p>改成如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">requirepass my_password</span><br></pre></td></tr></table></figure>

<p>保存之后重启redis服务器即可生效。</p>
<h2 id="redis模糊查询"><a href="#redis模糊查询" class="headerlink" title="redis模糊查询"></a>redis模糊查询</h2><ol>
<li><p>查询所有的key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>
</li>
<li><p>单字符匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys h?llo <span class="comment"># 可以匹配hello、hallo和hxllo等</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多字符匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys h*llo <span class="comment"># 可以匹配hello、heeeello等</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>范围内匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keys h[ae]llo <span class="comment"># 可以匹配hallo、hello</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu上创建自己的samba服务器</title>
    <url>/2021/08/08/samba-server-tutorial/</url>
    <content><![CDATA[<h2 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h2><p>类Unix（Gnu/Linux）操作系统上用来和标准Windows文件系统互相通信的一种程序套件；Samba允许类Unix系统和Windows系统共享文件和打印机，忽略两个系统间的差异性，从而实现共存。</p>
<h2 id="在ubuntu上安装Samba"><a href="#在ubuntu上安装Samba" class="headerlink" title="在ubuntu上安装Samba"></a>在ubuntu上安装Samba</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install -y samba</span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件，设置共享目录"><a href="#修改配置文件，设置共享目录" class="headerlink" title="修改配置文件，设置共享目录"></a>修改配置文件，设置共享目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建共享目录</span></span><br><span class="line">$ mkdir /tmp/share</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将共享目录添加到配置文件中</span></span><br><span class="line">$ sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>

<p>将下面的内容追加到文件末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[share]</span><br><span class="line">	comment = Samba share directory # 共享目录说明</span><br><span class="line">	path = /tmp/share # 共享目录的系统路径</span><br><span class="line">	read only = yes # 是否只读 </span><br><span class="line">    browsable = yes # 是否可浏览</span><br></pre></td></tr></table></figure>

<h2 id="修改默认端口（适用于公网访问的场景，内网访问可以不用修改）"><a href="#修改默认端口（适用于公网访问的场景，内网访问可以不用修改）" class="headerlink" title="修改默认端口（适用于公网访问的场景，内网访问可以不用修改）"></a>修改默认端口（适用于公网访问的场景，内网访问可以不用修改）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure>

<p>将下面的内容追加到<code>[global]</code>部分的末尾（如果端口配置已存在，则直接修改端口号）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">	...</span><br><span class="line">	smb ports = 4450 1390 #想要指定的端口号，原本为445 139</span><br></pre></td></tr></table></figure>

<h2 id="重启smbd守护进程"><a href="#重启smbd守护进程" class="headerlink" title="重启smbd守护进程"></a>重启smbd守护进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart smbd</span><br></pre></td></tr></table></figure>

<h2 id="查看修改后的端口号是否生效"><a href="#查看修改后的端口号是否生效" class="headerlink" title="查看修改后的端口号是否生效"></a>查看修改后的端口号是否生效</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ss -nltp | grep 4450</span><br><span class="line">$ ss -nltp | grep 1390</span><br></pre></td></tr></table></figure>

<h2 id="配置防火墙ufw"><a href="#配置防火墙ufw" class="headerlink" title="配置防火墙ufw"></a>配置防火墙ufw</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果开启了ufw,则需要将samba服务添加到允许访问服务列表中</span></span><br><span class="line">sudo ufw allow samba</span><br><span class="line"><span class="comment"># 如果重新配置了端口，则需要指定允许访问的端口号</span></span><br><span class="line">sudo ufw allow [port] <span class="comment"># 可以在端口号后面加上tcp或者udp,如1390/tcp、1390/udp</span></span><br></pre></td></tr></table></figure>

<h2 id="创建samba用户账户"><a href="#创建samba用户账户" class="headerlink" title="创建samba用户账户"></a>创建samba用户账户</h2><p>samba默认不使用系统账户，因此，我们需要为共享目录设置一个用户名和密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># 该命令会将当前用户加入到samba的用户中，并提示设置该用户对应的密码</span></span><br></pre></td></tr></table></figure>

<h2 id="验证samba服务的可用性"><a href="#验证samba服务的可用性" class="headerlink" title="验证samba服务的可用性"></a>验证samba服务的可用性</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install smbclient</span><br><span class="line"><span class="comment"># 验证可用的samba共享目录</span></span><br><span class="line">smbclient -L samba_server_ip</span><br><span class="line"><span class="comment"># 如果修改了默认端口号，还需要手动指定端口号</span></span><br><span class="line">smbclient -p 1390 -L samba_server_ip</span><br></pre></td></tr></table></figure>

<p>如果服务正常的话，会出现如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter WORKGROUP\pengkai<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Sharename       Type      Comment</span></span><br><span class="line"><span class="string">	---------       ----      -------</span></span><br><span class="line"><span class="string">	sambashare      Disk      Samba And linux</span></span><br><span class="line"><span class="string">	www-data        Disk      apache web root</span></span><br><span class="line"><span class="string">	print$          Disk      Printer Drivers</span></span><br><span class="line"><span class="string">	IPC$            IPC       IPC Service (kyleVps server (Samba, Ubuntu))</span></span><br><span class="line"><span class="string">SMB1 disabled -- no workgroup available</span></span><br></pre></td></tr></table></figure>

<h2 id="在终端中连接samba共享目录"><a href="#在终端中连接samba共享目录" class="headerlink" title="在终端中连接samba共享目录"></a>在终端中连接samba共享目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbclient -U [user] [-p port] //[samba_ip]/[share_directory] </span><br><span class="line"><span class="comment"># 上述命令需要指定登陆用户和samba服务器ip以及共享目录，随后系统会提示输入密码</span></span><br><span class="line"><span class="comment"># 密码验证通过之后会进入smb的命令行交互界面：</span></span><br><span class="line">Try <span class="string">&quot;help&quot;</span> to get a list of possible commands.</span><br><span class="line">smb: \&gt; ls</span><br><span class="line">  .                                   D        0  Sun Feb 21 18:42:49 2021</span><br><span class="line">  ..                                  D        0  Sun Feb 21 18:42:18 2021</span><br><span class="line">  Test File                           N       20  Sun Feb 21 18:42:49 2021</span><br><span class="line"> </span><br><span class="line">        971515904 blocks of size 1024. 843676384 blocks available</span><br><span class="line">smb: \&gt; </span><br></pre></td></tr></table></figure>

<h2 id="将samba挂载至指定目录下"><a href="#将samba挂载至指定目录下" class="headerlink" title="将samba挂载至指定目录下"></a>将samba挂载至指定目录下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">未完待续</span><br></pre></td></tr></table></figure>



<p>至此，samba的安装、配置和使用就说完了。</p>
]]></content>
      <categories>
        <category>文件共享服务</category>
      </categories>
      <tags>
        <tag>samba</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro的权限管理之访问许可（permission）</title>
    <url>/2021/09/03/shiro-permission-guide/</url>
    <content><![CDATA[<p><img src="/assets/lock.jpg"></p>
<h2 id="1-Apache-Shiro中的permission是什么"><a href="#1-Apache-Shiro中的permission是什么" class="headerlink" title="1. Apache Shiro中的permission是什么"></a>1. Apache Shiro中的permission是什么</h2><p>Shiro 将 Permission 定义为代表某个明确行为或动作的语句。 它是应用程序中原始功能的声明，仅此而已。 权限是安全策略中最低级别的结构，它们仅明确定义应用程序可以做什么，而不会描述谁可以做这些动作。（和subject即认证主体无关）</p>
<h2 id="2-permission体现在哪些地方"><a href="#2-permission体现在哪些地方" class="headerlink" title="2. permission体现在哪些地方"></a>2. permission体现在哪些地方</h2><ul>
<li><p>打开一个文件</p>
</li>
<li><p>访问<code>/user/list</code>路径下的网页</p>
</li>
<li><p>打印文档</p>
</li>
<li><p>删除某个用户</p>
</li>
</ul>
<p>定义“谁”（用户）被允许做“什么”（权限）是一种以某种方式为用户分配权限的运用，这始终由应用程序的数据模型完成，并且可能因应用程序而异。</p>
<p>例如，权限可以归入一个角色，并且该角色可以与一个或多个用户对象相关联。 或者一些应用程序可以有一个用户组，一个组可以分配一个角色，通过传递关联意味着该组中的所有用户都被隐式授予角色中的权限。</p>
<p>向用户授予权限的方式有多种变化——应用程序根据应用程序要求确定如何对此进行建模。</p>
<h2 id="3-通配符权限"><a href="#3-通配符权限" class="headerlink" title="3. 通配符权限"></a>3. 通配符权限</h2><p>上面的权限示例中，“打开文件”，“查看‘用户/列表’网页”等都是有效的权限声明。 然而，在计算上解释这些自然语言字符串并确定是否允许用户执行该行为将是非常困难的。因此，为了实现易于处理但仍然可读的权限语句，Shiro 提供了强大而直观的权限语法，我们称之为通配符权限。</p>
<h3 id="3-1-简单应用"><a href="#3-1-简单应用" class="headerlink" title="3.1 简单应用"></a>3.1 简单应用</h3><p>假设您想保护对公司打印机的访问，以便某些人可以打印到特定的打印机，而其他人可以查询当前队列中的作业。</p>
<p>一种极其简单的方法是授予用户“queryPrinter”权限。 然后您可以通过调用来检查用户是否具有 queryPrinter 权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subject.isPermitted(<span class="string">&quot;queryPrinter&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subject.isPermitted( <span class="keyword">new</span> WildcardPermission(<span class="string">&quot;queryPrinter&quot;</span>) )</span><br></pre></td></tr></table></figure>

<p>这还不够，简单权限字符串可能适用于简单的应用程序，但它需要您拥有“printPrinter”、“queryPrinter”、“managePrinter”等权限。您也可以使用通配符授予用户“*”权限（授予此权限） 构造其名称），这意味着它们拥有整个应用程序的所有权限。</p>
<p>但是使用这种方法，不能只说用户拥有“所有打印机权限”。 因此，通配符权限支持多级权限。</p>
<h3 id="3-2-多个部件"><a href="#3-2-多个部件" class="headerlink" title="3.2 多个部件"></a>3.2 多个部件</h3><p>通配符权限支持多个级别或部分的概念。 例如，您可以通过授予用户权限来重构前面的简单示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printer:query</span><br></pre></td></tr></table></figure>

<p>本示例中的冒号是一个特殊字符，用于分隔权限字符串中的下一部分。</p>
<p>在此示例中，第一部分是正在操作的域（打印机），第二部分是正在执行的操作（查询）。 上面的其他示例将更改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printer:print</span><br><span class="line">printer:manage</span><br></pre></td></tr></table></figure>

<p>可以使用的部件数量没有限制，因此就可以在您的应用程序中使用它的方式而言，这取决于您的想象力。</p>
<h4 id="3-2-1-多个值"><a href="#3-2-1-多个值" class="headerlink" title="3.2.1 多个值"></a>3.2.1 多个值</h4><p>每个部分可以包含多个值。 因此，与其同时授予用户“printer:print”和“printer:query”权限，您还可以简单地授予他们一个权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printer:print,query</span><br></pre></td></tr></table></figure>

<p>这使他们能够打印和查询打印机。 并且由于他们被授予了这两个操作，您可以检查用户是否有能力通过调用来查询打印机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">subject.isPermitted(<span class="string">&quot;printer:query&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这将返回 true。</p>
<h4 id="3-2-2-全部的值"><a href="#3-2-2-全部的值" class="headerlink" title="3.2.2 全部的值"></a>3.2.2 全部的值</h4><p>如果您想授予用户特定部分的所有值怎么办？ 这样做比手动列出每个值更方便。 同样，基于通配符，我们可以做到这一点。 如果打印机域有 3 个可能的操作（查询、打印和管理），则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printer:query,print,manage</span><br></pre></td></tr></table></figure>

<p>可以简化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printer:*</span><br></pre></td></tr></table></figure>

<p>然后，对“printer:XXX”的任何权限检查都将返回 true。 以这种方式使用通配符比显式列出操作更有效，因为如果稍后向应用程序添加新操作，则无需更新在该部分使用通配符的权限。</p>
<p>最后，还可以在通配符权限字符串的任何部分使用通配符标记。 例如，如果您想授予用户跨所有域（不仅仅是打印机）的“查看”操作，您可以授予以下权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*:view</span><br></pre></td></tr></table></figure>

<p>然后对“foo:view”的任何权限检查都将返回true。</p>
<p><strong>未完待续：<a href="https://shiro.apache.org/permissions.html">https://shiro.apache.org/permissions.html</a></strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>permission</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架中bean的生命周期</title>
    <url>/2021/08/09/spring-bean-init-and-destroy/</url>
    <content><![CDATA[<h2 id="使用-PostConstruct和-PreDestroy注解在同一个配置类中执行bean的初始化前和销毁前的配置"><a href="#使用-PostConstruct和-PreDestroy注解在同一个配置类中执行bean的初始化前和销毁前的配置" class="headerlink" title="使用@PostConstruct和@PreDestroy注解在同一个配置类中执行bean的初始化前和销毁前的配置"></a>使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解在同一个配置类中执行bean的初始化前和销毁前的配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是初始化前执行的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是销毁前执行的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置类中只定义了一个bean，且是字符串类型（方便举例），大部分情况下应该是返回一个对象。</p>
<h2 id="使用-Bean-initMethod-quot-init-quot-destroyMethod-quot-destroy-quot-注解执行bean初始化前和销毁前的配置"><a href="#使用-Bean-initMethod-quot-init-quot-destroyMethod-quot-destroy-quot-注解执行bean初始化前和销毁前的配置" class="headerlink" title="使用@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)注解执行bean初始化前和销毁前的配置"></a>使用<code>@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</code>注解执行bean初始化前和销毁前的配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function">Test1 <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Test1(); <span class="comment">// 使用默认的无参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Bean的内容，本质上是一个普通的java类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化前的执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is init method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁前的执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is destroy method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring framework</category>
      </categories>
      <tags>
        <tag>bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架中bean的前置处理和后置处理</title>
    <url>/2021/08/09/spring-bean-post-processor/</url>
    <content><![CDATA[<h2 id="Spring框架中Bean的创建过程如下："><a href="#Spring框架中Bean的创建过程如下：" class="headerlink" title="Spring框架中Bean的创建过程如下："></a>Spring框架中Bean的创建过程如下：</h2><p><img src="https://springframework.guru/wp-content/uploads/2019/05/aware_interfaces_callbacks_in_bean_lifecycle-1024x545.png" alt="Aware interfaces Callbacks in Bean Lifecycle"></p>
<p>其中BeanPostProcessor接口包含两个执行过程，分别是在bean执行init方法之前和执行init方法之后执行。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在bean初始化前执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在bean初始化之后执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;DBConnection&quot;, initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseConfig <span class="title">mysqlConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties properties = System.getProperties();</span><br><span class="line">        String url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driverName = properties.getProperty(<span class="string">&quot;driverName&quot;</span>);</span><br><span class="line">        String userName = properties.getProperty(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line">        String password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DatabaseConfig(driverName, url, userName, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码新建了自定义的<code>MyBeanPostProcessor</code>,并实现了接口<code>BeanPostProcessor</code>中的两个接口（自带default方法），同时，还定义了一个名为<code>DBConnection</code>的bean，指定了初始化方法和销毁前执行的方法。</p>
<p>其中，<code>DatabaseConfig</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String driverName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseConfig</span><span class="params">(String driverName, String url, String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driverName = driverName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造连接参数...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化数据库连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁数据库连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了方便识别执行阶段，分别在构造器和<code>init</code>以及<code>destroy</code>方法中加入了文字说明。</p>
<p>最后的执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造连接参数...</span><br><span class="line">我在bean初始化前执行</span><br><span class="line">初始化数据库连接</span><br><span class="line">我在bean初始化之后执行</span><br><span class="line">...</span><br><span class="line">销毁数据库连接</span><br></pre></td></tr></table></figure>

<p>由此可见，构造器内的代码是最先执行的，属于填充属性阶段（即<code>Populate properties</code>），接着执行<code>MyBeanPostProcessor#postProcessBeforeInitialization</code>方法，然后执行<code>init方法</code>，之后执行<code>MyBeanPostProcessor#postProcessBeforeInitialization</code>，最后在关闭应用时执行<code>destroy</code>方法。</p>
]]></content>
      <categories>
        <category>spring framework</category>
      </categories>
      <tags>
        <tag>bean</tag>
        <tag>post-processor</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架中的异常处理方式</title>
    <url>/2021/01/09/spring-exception-handle/</url>
    <content><![CDATA[<h2 id="1-在控制层验证参数"><a href="#1-在控制层验证参数" class="headerlink" title="1. 在控制层验证参数"></a>1. 在控制层验证参数</h2><p>@RequestParam(“arg”)可以用来限制调用方只能使用arg作为参数名来调用接口。</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-framework-core-thinking-1</title>
    <url>/2021/08/08/spring-framework-core-thinking-1/</url>
    <content><![CDATA[<h2 id="spring框架进阶—Aware接口的原理和使用"><a href="#spring框架进阶—Aware接口的原理和使用" class="headerlink" title="spring框架进阶—Aware接口的原理和使用"></a>spring框架进阶—Aware接口的原理和使用</h2>]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aware</tag>
      </tags>
  </entry>
  <entry>
    <title>spring实战</title>
    <url>/2021/03/14/spring-in-action/</url>
    <content><![CDATA[<h2 id="认识spring框架"><a href="#认识spring框架" class="headerlink" title="认识spring框架"></a>认识spring框架</h2><ol>
<li>spring框架为开发者做了很多，反过来，它也要求开发者同样对它。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc注解学习</title>
    <url>/2021/01/10/spring-mvc-annotation/</url>
    <content><![CDATA[<h2 id="annotation-driven"><a href="#annotation-driven" class="headerlink" title="annotation-driven"></a>annotation-driven</h2><p>配置注解驱动的Spring MVC控制器编程模型。</p>
<p>可选参数：</p>
<ul>
<li>conversion-service：指定字段转换服务</li>
<li>validator：指定自定义的校验类，用来校验控制器中的model对象，默认使用<code>JSR-303</code>校验</li>
</ul>
<h2 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h2><p>配置静态资源的处理器，比如说图片、js、css，通过对缓存头进行优化，提升浏览器的加载速度。允许Spring资源处理器能够识别任何指定路径下的静态资源。</p>
<p>可选参数：</p>
<ul>
<li>mapping：必须，指定URL的映射方式，基于当前的Servlet上下文，比如<code>/resources/**</code>则表示需要在url中加上resources，然后追加静态资源相对于根路经的目录结构路径。</li>
<li>location：必须，指定静态资源的物理路径，多个路径可以使用逗号隔开，放在前面的会被优先读取（如果有两个同名的文件，会优先读取放在前面的路径下的文件），例如：<code>/,classpath:/META-INF/public-web-resources/</code>，将会读取位于web应用根路径下的静态资源以及类路径下的所有Jar包中<code>/META-INF/public-web-resources</code>目录下的文件，而web应用根路径下的文件优先级更高。</li>
<li>cache-period：可选，指定静态资源的缓存策略。以秒为单位。默认情况下不会发送任何缓存头，而是取决于文件上次修改的时间戳。如果将该属性的值设为0,则会发送值为<code>prevent-cacheing</code>的缓存头。如果是大于0的值，则会发送<code>max-age</code>为该值的缓存头。</li>
<li>order：可选，指定资源处理器的顺序。</li>
</ul>
<h2 id="default-servlet-handler"><a href="#default-servlet-handler" class="headerlink" title="default-servlet-handler"></a>default-servlet-handler</h2><p>用来配置处理静态资源的处理器（handler），通过将请求重定向到容器默认的servlet。使用这个处理器允许<code>/</code>映射与<code>DispatcherServlet</code>一起使用，同时仍利用Servlet容器提供静态资源服务。</p>
<p>可用属性：</p>
<ul>
<li><p>default-servlet-name：可以重定向客户端静态资源请求的默认Servlet。默认的处理器在启动时会自动检测容器默认的Servlet（通过一个预定义的名字列表）。只有在默认但Servlet无法被检测到的情况下，才需要明确指定默认Servlet的名字。</p>
</li>
<li><p>interceptors：注册自定义的拦截器（父标签）</p>
<ul>
<li><p>interceptor：自定义拦截器必须继承HandlerInterceptor类或者实现WebRequestInterceptor接口。</p>
<p>可用属性</p>
<ul>
<li>mapping：<ul>
<li>path：指定被拦截的url路径，例如<code>/myPath</code>或者<code>/myPath/**</code></li>
<li>ref：指定bean的引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="view-controller"><a href="#view-controller" class="headerlink" title="view-controller"></a>view-controller</h2><p>用来定义渲染返回视图的简单控制器</p>
<p>可用属性：</p>
<ul>
<li>path：必须。被映射的URL路径。</li>
<li>view-name：可选。被渲染的视图名，如果不指定，则通过当前HttpServletRequest对应的DispatcherServlet的RequestToViewNameTranslator来决定。</li>
</ul>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>annotation</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用openssh进行远程连接</title>
    <url>/2020/12/27/ssh-manual/</url>
    <content><![CDATA[<h2 id="SSH连接的建立方式"><a href="#SSH连接的建立方式" class="headerlink" title="SSH连接的建立方式"></a>SSH连接的建立方式</h2><p>ssh可以通过密码和密钥（更加安全）这两种方式建立起客户端与 服务端的连接。</p>
<h2 id="SSH连接的实现过程（假设通过密钥的方式连接）"><a href="#SSH连接的实现过程（假设通过密钥的方式连接）" class="headerlink" title="SSH连接的实现过程（假设通过密钥的方式连接）"></a>SSH连接的实现过程（假设通过密钥的方式连接）</h2><ol>
<li>当客户端发起一个ssh连接请求时，它首先会告诉服务端需要使用的公钥；</li>
<li>然后服务端会检查它的<code>~/authorized_keys</code>文件，这个文件中包含了所有已经保存的客户端公钥，一个公钥占据一行，这些公钥所对应的客户端可以实现免验证登录。</li>
<li>服务端如果在文件中找到了请求客户端所对应的公钥，就会生成一个随机字符串，并使用找到的公钥进行加密。这个加密后的信息只能被请求客户端的私钥所解密，然后服务端将这个加密后的字符串发送给请求客户端，以此来验证该客户端是否拥有私钥。</li>
<li>客户端收到来自服务端的加密字符串之后，会立即使用自己的私钥进行解密，并将解密后的随机字符串与之前协商好的会话id结合，生成一个md5加密的hash值，并回传给服务端。</li>
<li>由于服务端已经知道加密之前的随机字符串和会话id，因此，服务端会在本地将这个随机字符串和会话id进行hash，然后和客户端传过来的值进行比较，如果一致，则表示请求客户端确实拥有私钥，并允许建立连接。<span id="more"></span>
<h2 id="生成SSH密码对"><a href="#生成SSH密码对" class="headerlink" title="生成SSH密码对"></a>生成SSH密码对</h2>有几种加密算法可以用来生成SSH密钥，例如RSA、DSA、ECDSA，默认情况下使用RSA加密算法。<br>使用如下命令可以生成一个默认的密钥：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/demo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>这里可以指定密钥文件的保存位置。默认是<code>~/.ssh/id_rsa</code>。<br>点击<code>enter</code>进入下一步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>这里可以指定密钥的密码短语，即在密码之上再加一层密码验证，增强密钥的安全性。<br>点击<code>enter</code>进入下一步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">8c:e9:7c:fa:bf:c4:e5:9c:c9:b8:60:1f:fe:1c:d3:8a root@here</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|       +         |</span></span><br><span class="line"><span class="string">|      o S   .    |</span></span><br><span class="line"><span class="string">|     o   . * +   |</span></span><br><span class="line"><span class="string">|      o + = O .  |</span></span><br><span class="line"><span class="string">|       + = = +   |</span></span><br><span class="line"><span class="string">|      ....Eo+    |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br></pre></td></tr></table></figure>
<p>这时，你的密钥对就算生成成功了。生成的文件如下：</p>
<ul>
<li><code>~/.ssh/id_rsa</code>:存放你的私钥。<strong>只能你自己知道</strong>。</li>
<li><code>~/.ssh/id_rsa.pub</code>:存放你的公钥，可以让其他人知道。<h2 id="使用更长的位数生成你的密钥对"><a href="#使用更长的位数生成你的密钥对" class="headerlink" title="使用更长的位数生成你的密钥对"></a>使用更长的位数生成你的密钥对</h2>默认情况下，ssh-keyken使用2048的位长度生成密钥对。这一默认值大多数场合已经足够安全，但是，我们在某些特殊场景下仍然可以使用更大的位长度来增强我们服务器的安全性。<br>为了做到这一点，我们可以使用<code>-b</code>参数来指定我们需要的位长度。<br>比如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -b 4096</span><br></pre></td></tr></table></figure>
如果你之前已经生成过一个密钥对，那么这里会提示你是否需要覆盖你之前的键：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Overrite(Y/n)?</span><br></pre></td></tr></table></figure>
如果你选择是，那你之前的文件会被覆写，导致你再也无法使用之前的密钥登录到之前的服务器，因此，一定要小心之前的密钥是否需要保留。<h2 id="移除或者修改私钥的密码短语-passphase"><a href="#移除或者修改私钥的密码短语-passphase" class="headerlink" title="移除或者修改私钥的密码短语(passphase)"></a>移除或者修改私钥的密码短语(passphase)</h2>如果你已经为你的私钥指定了一个密码短语，该怎么修改或者直接删除这个密码短语呢？<div class="note info"><p>为了修改或移除密码短语，你必须知道原来的密码短语。如果你忘记了原来的密码短语，你将无法再次使用该密钥，必须重新生成新的密钥。</p>
</div>
通过下面的命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -p</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> the key is (/root/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
你可以指定密钥的位置，或者直接按<code>Enter</code>接受默认的位置。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter old passphrase:</span><br></pre></td></tr></table></figure>
输入你希望修改的旧密码，然后你会被提示输入一个新的密码短语：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter new passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
至此，输入你的新密码短语或者按<code>Enter</code>来移除密码短语。<h2 id="展示SSH密钥的手印（Fingerprint）"><a href="#展示SSH密钥的手印（Fingerprint）" class="headerlink" title="展示SSH密钥的手印（Fingerprint）"></a>展示SSH密钥的手印（Fingerprint）</h2>每个SSH密钥对共享一个密码形式的“手印”，它可以被用来唯一标识密钥对。这在有些情况下会很有用。<br>为了查看现有的密钥对，你可以执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -l</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter file in which the key is (/root/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
你可以直接按<code>Enter</code>选择默认的密钥的位置，或者输入你期望的位置。之后你会得到包含了密钥的位长、手印和帐号以及所选主机和使用的算法的字符串：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4096 8e:c4:82:47:87:c2:26:4b:68:ff:96:1a:39:62:9e:4e  demo@<span class="built_in">test</span> (RSA)</span><br></pre></td></tr></table></figure>
<h2 id="使用SSH-Copy-ID复制公钥到服务器"><a href="#使用SSH-Copy-ID复制公钥到服务器" class="headerlink" title="使用SSH-Copy-ID复制公钥到服务器"></a>使用SSH-Copy-ID复制公钥到服务器</h2>通过将你的公钥复制到服务器，可以让你不用输入密码就可以通过认证，有很多方法可以实现这一点。<br>如果你当前有一个基于密码的SSH远程服务器访问方式，并且你已经安装了ssh-copy-id工具，那么你就可以很容易的实现这一点。而且ssh-copy-id已经预装到了大多数的linux发行版中。<br>通过下面的命令可以实现这一点：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-copy-id username@remote_host</span><br></pre></td></tr></table></figure>
随后会提示你输入当前用户在远程服务器上的密码，正确输入之后，你本地的公钥就会被添加到服务器用户的<code>~/.ssh/authorized_keys</code>文件中，之后，你就可以不用输入密码也能登录到远程服务器了。<h2 id="不通过ssh-copy-id命令将公钥添加到远程服务器"><a href="#不通过ssh-copy-id命令将公钥添加到远程服务器" class="headerlink" title="不通过ssh-copy-id命令将公钥添加到远程服务器"></a>不通过ssh-copy-id命令将公钥添加到远程服务器</h2>如果你没有安装ssh-copy-id命令行工具，那你应该怎么样将你的公钥上传到远程服务器呢？通过linux中的管道命令，我们可以实现这一点。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub | ssh username@remote_host <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure>
<p>随后根据提示输入远程主机的用户名密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;111.111.11.111 (111.111.11.111)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">demo@111.111.11.111&#x27;</span>s password:</span><br></pre></td></tr></table></figure>
<p>如果添加成功，你之后的登录将无需再次输入密码，而是简单的通过如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh username@remote_ip_host</span><br></pre></td></tr></table></figure>
<h2 id="手动将你的密钥复制到服务器"><a href="#手动将你的密钥复制到服务器" class="headerlink" title="手动将你的密钥复制到服务器"></a>手动将你的密钥复制到服务器</h2><p>如果你没有可用的基于密码访问的SSH连接，你将必须手动将你的公钥复制到远程服务器。<br>打开你的本地终端，输入下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>将输出到屏幕上的公钥复制到剪贴板，然后通过工具（一般是服务器供应商提供的web面板）连接到远程服务器，并在远程服务器的<code>~/.ssh/</code>（如果不存在就新建）目录下面创建<code>authorized_keys</code>文件。最后将你复制的公钥粘贴到该文件中，并保存。</p>
<h2 id="基本的连接指令"><a href="#基本的连接指令" class="headerlink" title="基本的连接指令"></a>基本的连接指令</h2><p>接下来是针对SSH中一些比较常用的命令做个说明。</p>
<h3 id="连接到指定的远程服务器"><a href="#连接到指定的远程服务器" class="headerlink" title="连接到指定的远程服务器"></a>连接到指定的远程服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh remote_host</span><br></pre></td></tr></table></figure>
<p>这个命令会假设你当前机器的本地用户名和远程服务器上的用户名是一致的。如果不一致，请使用下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh username@remote_host</span><br></pre></td></tr></table></figure>
<p>这个命令会假设你要连接的远程服务器的端口号是22（ssh默认的端口号）。如果不是，请使用<code>-p your_port</code>指定你的自定义端口号。<br>如果服务器正常开启了ssh服务以及对应的监听端口，那么你会看到如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;111.111.11.111 (111.111.11.111)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br></pre></td></tr></table></figure>
<p>输入”yes”即可接受来自远程服务器的验证。<br>如果你使用了密码验证，那么你会被要求输入密码，如果你使用了公钥免登录，且设置了密码短语，那么你将同样被要求输入密码短语，否则，你将自动登录成功。</p>
<h2 id="在远程服务器上执行单次命令"><a href="#在远程服务器上执行单次命令" class="headerlink" title="在远程服务器上执行单次命令"></a>在远程服务器上执行单次命令</h2><p>如果你只是想在远程服务器上执行单个命令，并不想开启一次远程会话。那么你可以通过下面的命令来完成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh username@remote_host commander_to_run</span><br></pre></td></tr></table></figure>
<p>这个命令会在连接上远程服务器之后立即执行后面的命令，随后便会关闭连接。</p>
<h2 id="使用配置文件简化连接输入"><a href="#使用配置文件简化连接输入" class="headerlink" title="使用配置文件简化连接输入"></a>使用配置文件简化连接输入</h2><p>在<code>~/.ssh</code>目录下新建<code>config</code>文件（如果不存在的话），并输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host remote_aliss <span class="comment"># 远程主机别名</span></span><br><span class="line">    HostName remote_host <span class="comment">#远程主机</span></span><br><span class="line">    Port port_num <span class="comment"># 端口号</span></span><br><span class="line">    User your_user <span class="comment"># 登录用户</span></span><br><span class="line">    IdentityFile ~/.ssh/id_rsa <span class="comment"># 要使用的密钥</span></span><br></pre></td></tr></table></figure>
<p>配置完成之后，之后的连接只需要通过输入如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh remote_alias</span><br></pre></td></tr></table></figure>
<h2 id="使用SSH-Agent保存密码短语，避免重复输入"><a href="#使用SSH-Agent保存密码短语，避免重复输入" class="headerlink" title="使用SSH Agent保存密码短语，避免重复输入"></a>使用SSH Agent保存密码短语，避免重复输入</h2><p>如果你对密钥使用了密码短语进行加密，那么你在每次建立SSH连接会话之前都会要求输入密码短语，为了简化连接过程，避免每次都要重复输入，你可以使用SSH Agent来保存你的密码短语。</p>
]]></content>
      <categories>
        <category>生涯 SSH连接的建立方式</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>string-in-file-search</title>
    <url>/2021/08/08/string-in-file-search/</url>
    <content><![CDATA[<h2 id="在指定目下寻找包含指定字符串的文件："><a href="#在指定目下寻找包含指定字符串的文件：" class="headerlink" title="在指定目下寻找包含指定字符串的文件："></a>在指定目下寻找包含指定字符串的文件：</h2><ol>
<li>输出文件名和内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep mysqli_connect ./</span><br></pre></td></tr></table></figure>

<p>其中，，</p>
<ul>
<li><p>加入<code>-r</code>可以递归搜索</p>
</li>
<li><p>加入<code>-l</code>可以只打印匹配的文件名</p>
</li>
<li><p>加入参数<code>-e</code>可以支持正则表达式</p>
</li>
<li><p>加入参数<code>-i</code>可以不区分大小写</p>
</li>
<li><p>加入参数<code>-c</code>可以指定匹配的行数</p>
</li>
<li><p>加入<code>-v</code>可以查出不匹配指定字符串的行数</p>
</li>
</ul>
<ol start="2">
<li><p>替换上述匹配命令中的匹配字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/mysqli_connect/mysql_connect/g&quot;</span> `grep mysqli_connect -rl ./`</span><br></pre></td></tr></table></figure>

<p>其中，<code>-i</code>表示替换立即生效</p>
</li>
</ol>
]]></content>
      <categories>
        <category>字符串处理</category>
      </categories>
      <tags>
        <tag>grep</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>学习资源汇总</title>
    <url>/2021/08/20/study-resource-collection/</url>
    <content><![CDATA[<ol>
<li><p>分布式搜索引擎elasticsearch学习教程——<a href="https://www.tutorialspoint.com/elasticsearch/elasticsearch_populate.htm">https://www.tutorialspoint.com/elasticsearch/elasticsearch_populate.htm</a></p>
</li>
<li><p>java权限认证框架shiro——<a href="https://shiro.apache.org/authentication.html">https://shiro.apache.org/authentication.html</a></p>
</li>
<li><p>vue+bootstrap4学习——<a href="https://www.remotestack.io/build-vue-login-signup-ui-auth-template-with-bootstrap/">https://www.remotestack.io/build-vue-login-signup-ui-auth-template-with-bootstrap/</a></p>
</li>
<li><p>druid学习资源——<a href="https://druid.apache.org/docs/latest/configuration/index.html">https://druid.apache.org/docs/latest/configuration/index.html</a></p>
</li>
<li><p>java日志框架logback——<a href="https://dennis-xlc.gitbooks.io/the-logback-manual/content/en/chapter-4-appenders/logback-core/rollingfileappender/size-and-time-based-rolling-policy.html">https://dennis-xlc.gitbooks.io/the-logback-manual/content/en/chapter-4-appenders/logback-core/rollingfileappender/size-and-time-based-rolling-policy.html</a></p>
</li>
<li><p>springboot官方文档——<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#legal">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#legal</a></p>
</li>
<li><p>java缩写解释：<a href="https://www.allacronyms.com/EIS/Enterprise_Information_Server">https://www.allacronyms.com/EIS/Enterprise_Information_Server</a></p>
</li>
<li><p>hexo使用文档：<a href="https://hexo.io/docs/writing.html">https://hexo.io/docs/writing.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows 10中访问wsl（linux子系统）的方式（反过来又如何）</title>
    <url>/2021/04/01/the-way-of-accessing-wsl-file-system-in-windows/</url>
    <content><![CDATA[<h2 id="在windows文件管理器中访问wsl（windows-subsystem-for-linux）文件系统"><a href="#在windows文件管理器中访问wsl（windows-subsystem-for-linux）文件系统" class="headerlink" title="在windows文件管理器中访问wsl（windows subsystem for linux）文件系统"></a>在windows文件管理器中访问wsl（windows subsystem for linux）文件系统</h2><ol>
<li>进入安装好的wsl终端，输入如下命令： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ explorer.exe .</span><br></pre></td></tr></table></figure>
 其中，<code>explorer.exe</code>为文件管理器的可执行文件，<code>.</code>代表当前目录（家目录）。<h2 id="在wsl中访问windows的本地文件"><a href="#在wsl中访问windows的本地文件" class="headerlink" title="在wsl中访问windows的本地文件"></a>在wsl中访问windows的本地文件</h2></li>
<li>默认情况下，windows的各个分区以盘符作为挂载点，在wsl中可以通过目录<code>/mnt/c</code>进行访问，其中<code>c</code>代表C盘，其他分区依次类推。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /mnt/c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在linux哲学中，一切皆是文件。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>迪迦奥特曼带给我的思考</title>
    <url>/2021/09/28/ultraman-classic/</url>
    <content><![CDATA[<h1 id="第49集——奥特之星"><a href="#第49集——奥特之星" class="headerlink" title="第49集——奥特之星"></a>第49集——奥特之星</h1><h2 id="剧情演说"><a href="#剧情演说" class="headerlink" title="剧情演说"></a>剧情演说</h2><p>在这一集中，大古追踪穿越时空回到过去寻找怪兽的外星人查利加，和他一同回到了圆古英二导演还在世时的1965年。随后，大古在不经意间误闯进了圆古英二导演的摄影棚，临时充当了本该由长野（博）担任的场务一职，令人没想到的是，看到一身胜利队队服的大古，愣是没有一个人发现大古其实并不是长野（博），当然，在现实中，大古的扮演者就叫做长野博，这也是导演刻意给我们开的一个玩笑，不算剧情bug。</p>
<p>离开摄影棚之后，大古找到了查利加，并质问他的真正意图，但查利加并不想告诉大古，反而向他发起了攻击，愤怒的大古拿出武器击退了查利加，而查利加也随之消失不见了。</p>
<p>接下来的剧情中，还出现了真正的长野和大古见面的场景，不得不说，这种虚实相间的拍摄手法的确能够触动观众的情绪，带给观众一种说不出的感动。</p>
<p>镜头给到初代奥特曼剧本创作人的金城哲夫，此时的他还在苦苦构思如何写出一个另圆古一导演（圆古英二导演的儿子）满意的剧本，但反复改了8次还是不能让导演满意，最后一次勉强让导演满意了，可是随后的一句“这故事有趣吗”再次让金城陷入了重写剧本的境遇。正当金城绞尽脑汁想剧本的时候，圆古英二导演主动和他聊起了剧本创作遇到的困难，并将自己的一颗红宝石拿给金城看，还告诉他这是外星人送给他的，而自己和这个外星人是好朋友。原来圆古英二导演曾经遇到过一个来自M78星云的奥特曼，而当时这个奥特曼正将一只怪兽沉到湖底，后来，为了表示对地球人的友好，他将一颗奥特之星送给了圆古英二导演，并告诉他这颗奥特之星会对他产生帮助。然而他们之间的对话被躲在门外的查利加偷听到了，而圆古英二提到的被奥特曼沉到湖底的怪兽正是他所要寻找的亚那加基。</p>
<p>得到消息的查利加立刻赶到龙森湖救出被封印的亚那加基，并命令怪兽破坏人类的住所。怪兽的出现引起了大古的注意，为了阻止怪兽继续破坏地球，大古拿起神光棒，变身成了迪迦奥特曼，和怪兽展开了搏斗，谁知怪兽丝毫不落下风，反而挟持住了迪迦，并吸取他的能量，眼看迪迦就要被打败，一旁观战的圆古英二导演凭借自己的意念竟然也变成了一道光，朝着怪兽发动攻击，击退了正在吸取迪迦能量的怪兽之后，这道光居然变成了奥特曼，并将迪迦被吸取的能量重新输入到了他的体内。得到能量后的迪迦再次回到战斗，和另一个奥特曼同时发动光线技能，一举打败了怪兽。而操纵怪兽的查利加则放出一句“后会有期”之后就逃跑了。圆古英二看着两位巨人，说道“我们需要一个英雄，金城，英雄是必要的“。而此时的金城正在埋头书写关于英雄的故事。</p>
<p>最后一幕是圆古英二导演拿着金城写出来的奥特英雄的剧本开始了初代奥特曼剧集的拍摄。之后的事情我们也都知道了。从此，奥特曼宇宙开启了崭新的一页。</p>
<h2 id="观后感"><a href="#观后感" class="headerlink" title="观后感"></a>观后感</h2><p>作为一部平成年代的开山之作，《迪迦奥特曼》与圆谷制作的上一部奥特曼剧集中间已经整整间隔了16年，而16年前观看奥特曼的小孩子很多都已经长大成人，主打孩童向的奥特曼似乎已经和他们渐行渐远。或许正是基于这一考量，《迪迦奥特曼》从一开始面向的就是成人观众。还记得小时候看迪迦，更多的是关注奥特曼打小怪兽，至于为什么要打怪兽以及人类未来的命运则完全不加考虑，只知道这个奥特曼长得特别好看，还能变身成其他两种形态，真的太酷了。当我们长大后再次打开《迪迦奥特曼》，我们突然发现这个奥特曼似乎有点不一样，曾经我们心中无敌的奥特曼似乎也在慢慢变得不那么无敌，原来，奥特曼也是人变的，他也会受伤，甚至奥特曼还需要我们人类的帮助才能打败那些怪兽，不仅是奥特曼，那些被他打的怪兽也变了，似乎没有天生就是怪兽的，都是因为人类肆意破坏地球，盲目发展高科技，才使我们的身边多了这么多怪兽，而来自外太空的外星人之所以要侵略地球，毁灭人类，只是因为他们想活下去，而奥特曼既是光，同时也是人类，为了人类的生存，奥特曼必须站出来打倒怪兽。即使面对一个根本赢不了的敌人，奥特曼也要以人类的身份战斗到最后一刻。很难想象一向主打孩童向的特摄片居然能在短短的一集20多分钟的剧情中注入如此崇高的立意，也让长大后的我们知道原来《迪迦奥特曼》根本就不是一部面向孩童的特摄片。我们都误会他了。作为连接昭和和平成奥特曼的桥梁，迪迦在奥特之星中完成了这一神圣的交接仪式，当我们看到初代奥特曼和迪迦在圆谷英二导演面前握手时，我们知道，随着圆谷英二导演的去世以及平成时代的到来，未来的奥特曼系列将开启新的篇章，而这一切都将从迪迦奥特曼开始。——谨以此文献给我们的童年，永远的迪迦奥特曼。</p>
]]></content>
      <categories>
        <category>迪迦</category>
      </categories>
      <tags>
        <tag>奥特曼</tag>
      </tags>
  </entry>
  <entry>
    <title>在docker中使用mysql</title>
    <url>/2021/01/12/use-mysql-inside-docker/</url>
    <content><![CDATA[<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器是一种标准化的软件单元，它允许开发者将他们的应用的执行环境和机器环境隔离开来，可以解决类似”它在我机器上工作的好好的“的抱怨。而Docker是目前容器领域的实际标准。</p>
<p>Docker的另外一个重要的用途是开发者可以下载并运行任何容器化的应用，而不用在他们的本地安装。因此很多应用都实现了容器化版本。</p>
]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>我们为什么喜欢迪迦奥特曼——迪迦被禁播后的感想</title>
    <url>/2021/09/26/why-we-like-ultraman-tiga/</url>
    <content><![CDATA[<h1 id="谁能想到，2021年的9月24日，这个看似格外普通的日子，却也是陪伴我们童年一路走来的特摄剧《迪迦奥特曼》上映25周年，居然在一片举报声中无声无息的全网下架，对于奥迷来说，这是一个值得被记住的日子，而对于期盼国产动漫能早日赶超国际水平的国人而言，这次的禁令不能不让我们心寒，或许我们希望的那一天永远都不会到来了。"><a href="#谁能想到，2021年的9月24日，这个看似格外普通的日子，却也是陪伴我们童年一路走来的特摄剧《迪迦奥特曼》上映25周年，居然在一片举报声中无声无息的全网下架，对于奥迷来说，这是一个值得被记住的日子，而对于期盼国产动漫能早日赶超国际水平的国人而言，这次的禁令不能不让我们心寒，或许我们希望的那一天永远都不会到来了。" class="headerlink" title="谁能想到，2021年的9月24日，这个看似格外普通的日子，却也是陪伴我们童年一路走来的特摄剧《迪迦奥特曼》上映25周年，居然在一片举报声中无声无息的全网下架，对于奥迷来说，这是一个值得被记住的日子，而对于期盼国产动漫能早日赶超国际水平的国人而言，这次的禁令不能不让我们心寒，或许我们希望的那一天永远都不会到来了。"></a>谁能想到，2021年的9月24日，这个看似格外普通的日子，却也是陪伴我们童年一路走来的特摄剧《迪迦奥特曼》上映25周年，居然在一片举报声中无声无息的全网下架，对于奥迷来说，这是一个值得被记住的日子，而对于期盼国产动漫能早日赶超国际水平的国人而言，这次的禁令不能不让我们心寒，或许我们希望的那一天永远都不会到来了。</h1><p><img src="/assets/tiga-ultraman.png"></p>
<h2 id="迪迦带给我们的感动"><a href="#迪迦带给我们的感动" class="headerlink" title="迪迦带给我们的感动"></a>迪迦带给我们的感动</h2><p>我们总说迪迦代表的是<strong>光</strong>，其实我们喜欢迪迦的真正原因是我们信仰迪迦带给我们的<strong>希望</strong>和<strong>与黑暗势力抗争到底的决心和勇气</strong>。</p>
<p>在迪迦奥特曼中，人类不停的被外来生物入侵，作为承担保护地球责任的地球防卫队——GUTS组织，在正面对抗体型庞大的怪兽和拥有高科技的外星人时根本也是无能为力，如果没有迪迦奥特曼的帮助，人类早就被毁灭几十次了，即使在面对没有丝毫破坏力的奇杰拉时，人类的表现也是令人失望的，因为人类宁愿活在虚无缥缈的幻境中，去逃避现实中的种种不堪，也不愿为了人类的未来去努力拼搏，积极进取，人类到底是一种软弱的生物。即便是迪迦之前的超古代奥特战士在看到这样的人类之后也只能任其毁灭，因为他们不是人类，对于浩瀚的宇宙而言，人类也只是其中渺小的一份子，如同大部分宇宙生物一样，自生自灭就是最好的生存法则。但是，这一切在迪迦出现后就完全变了，作为人类的大古机缘巧合之下获得了迪迦留在地球的巨人身躯，从一个普通的人类变成了保护地球的奥特战士，一次次以人类的身份比肩神明，为了人类的生存义无反顾的同凶残的巨型怪兽和邪恶的外星生物进行战斗，甚至在人类对奥特曼失去信任，反而帮助外星人诋毁奥特曼时也坚持维护人类免受灭顶之灾，如果这样的迪迦奥特曼都不能称之为英雄，并受到人类的尊敬和爱戴，那这人间或许本就该成为奇杰拉的墓场，这样的文明即使毁灭也无妨。迪迦奥特曼不仅带给我们希望，还教会了我们很多的道理，其中不乏对于人与人，人与科技，人与环境，人与地球，人与宇宙的深度思考，而这些看似宏大的人生理念，却在迪迦奥特曼中得到了很好的诠释。如果对于这样的一部作品都要冠以暴力的称谓而加以禁播，可想而知我们的社会中还有多少看似人模狗样，实则满肚子鸡鸣狗盗，阳奉阴违之人。这样的人无论是作为个人还是父母，对于人类的进步和社会的稳定都是一大阻碍，因为在他们眼中任何表达美好事物的东西都会被他们过滤在外，而最终留给他们的只能是暴力，于人于己，这样的人都是社会的毒瘤，而为他们提供滋生土壤的人也难辞其咎。此时此刻，迪迦或许只是暂时的离开，但他的精神会永远留在我们心中。迪迦奥特曼保护人类，更是为了保护我们人类赖以生存的美丽地球。</p>
]]></content>
      <categories>
        <category>奥特曼</category>
      </categories>
      <tags>
        <tag>迪迦</tag>
      </tags>
  </entry>
  <entry>
    <title>win10企业版激活方法</title>
    <url>/2021/04/01/win10-activate/</url>
    <content><![CDATA[<h2 id="本文主要介绍如何通过kms服务器实现Windows-10专业版和企业版激活。"><a href="#本文主要介绍如何通过kms服务器实现Windows-10专业版和企业版激活。" class="headerlink" title="本文主要介绍如何通过kms服务器实现Windows 10专业版和企业版激活。"></a>本文主要介绍如何通过kms服务器实现Windows 10专业版和企业版激活。</h2><ul>
<li><p>安装完系统之后，按住<code>Win+X</code>键，选择<code>Windows PowerShell（管理员）</code>,在弹出的窗口中输入下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># win10专业版用户</span></span><br><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br><span class="line"><span class="comment"># win10企业版用户</span></span><br><span class="line">slmgr /ipk NPPR9-FWDCX-D2C8J-H872K-2YT43</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑到一般笔记本厂商会预装win10家庭版，所以，在使用上面的办法之前需要先升级到win10专业版。步骤如下：</p>
<ol>
<li><p>打开<code>设置</code>页面，选择<code>更新和安全</code>，继续选择<code>激活</code>，点击<code>更改产品密钥</code>，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">J7QT3-3GCPG-9GVWT-CH2XR-GMRJM</span><br></pre></td></tr></table></figure>

<p>点击下一步</p>
</li>
<li><p>在提示页面点击更新即可。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title>为树莓派配置国内软件源</title>
    <url>/2021/11/18/add-china-software-source-for-raspberry-pi/</url>
    <content><![CDATA[<h2 id="因为众所周知的原因，树莓派的国外软件源在国内访问速度非常考验耐性，所以，为了能让树莓派愉快的更新到最新版本，有必要将默认的软件源替换成国内的同步镜像。下面就以清华大学的镜像站点为例子进行说明"><a href="#因为众所周知的原因，树莓派的国外软件源在国内访问速度非常考验耐性，所以，为了能让树莓派愉快的更新到最新版本，有必要将默认的软件源替换成国内的同步镜像。下面就以清华大学的镜像站点为例子进行说明" class="headerlink" title="因为众所周知的原因，树莓派的国外软件源在国内访问速度非常考验耐性，所以，为了能让树莓派愉快的更新到最新版本，有必要将默认的软件源替换成国内的同步镜像。下面就以清华大学的镜像站点为例子进行说明"></a>因为众所周知的原因，树莓派的国外软件源在国内访问速度非常考验耐性，所以，为了能让树莓派愉快的更新到最新版本，有必要将默认的软件源替换成国内的同步镜像。下面就以清华大学的镜像站点为例子进行说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 将默认的软件源注释掉，新增如下的配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi</span><br></pre></td></tr></table></figure>

<p>其中<code>bullseye</code>为当前树莓派系统的版本代号，可以参考默认的国外源的镜像配置中的代号，保持一致即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apt/sources.list.d/raspi.list</span><br><span class="line"><span class="comment"># 将默认的软件源注释掉，并新增如下的配置</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ bullseye main</span><br></pre></td></tr></table></figure>

<p><code>bullseye</code>和默认配置的保持一直即可。</p>
]]></content>
      <categories>
        <category>raspberry pi</category>
      </categories>
      <tags>
        <tag>国内源</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么在linux上清除命令的输出内容</title>
    <url>/2021/11/15/how-to-discard-output-on-linux/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -al &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>执行上面的命令之后你会发现终端没有任何输出，为什么会这样呢？</p>
<p>继续执行下面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -qwer &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>发现还是没有任何输出，即使该命令是错误的。</p>
<p>造成这一切的根源在于命令最后面的<code>2&gt;&amp;1</code>。</p>
<p>我们知道<code>/dev/null</code>是<code>linux</code>系统上的伪设备文件，可以被用来消除来自程序的输出。尤其是对于命令行程序而言有更大的意义。</p>
<p><code>/dev/null</code>看起来像是一个水漕，比如说一个可写的目标文件，然而只要有任何数据流被写入这个文件，都会被马上删除。</p>
<p>当用户不需要来自程序的输出信息时，这个命令是有用的。因为程序可能会生成大量的输出内容，而这会给分析日志的工作带来混乱。</p>
<p>对于<code>/dev/null 2&gt;&amp;1</code>命令，2在linux上代表STDERR（标准错误输出），而1则代表STDOUT（标准输出）。因此，这个命令的最终解释就是将标准错误输出和标准输出重定向到<code>/dev/null</code>，即消除这两种类型的输出。</p>
<p>我们再来具体分析下这个命令的构成，首先<code>&gt;</code>表示重定向，而被重定向的对象则是<code>/dev/null</code>。而不是打印到终端。</p>
<p>这是否意味着该命令所有的输出都会被重定向到<code>/dev/null</code>呢，并不是，因为它只会重定向标准输出。</p>
<p>因此，还需要加上<code>2&gt;&amp;1</code>。表示将2（标准错误输出）重定向到1（标准输出）。那么<code>&amp;</code>代表什么意思呢？如果不加上<code>&amp;</code>的话，标准错误输出将会输出到名字为1的文件中。而<code>&amp;</code>会告诉系统1不是一个文件，而是一个标准输出描述符号。</p>
<p>最后，我们将标准输出和标准错误输出都重定向到了<code>/dev/null</code>。而<code>/dev/null</code>会将所有的输出内容全部清除掉。</p>
<blockquote>
<p>小结：/dev/null是linux系统上一个特殊的设备文件，可以将任何命令的标准输出（不管是标准输出还是错误输出）清除掉。</p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>输出</tag>
      </tags>
  </entry>
  <entry>
    <title>IT老齐的架构课程之缓存</title>
    <url>/2021/12/12/it-laoqi-architecture-cache/</url>
    <content><![CDATA[<h2 id="使用缓存的目的"><a href="#使用缓存的目的" class="headerlink" title="使用缓存的目的"></a>使用缓存的目的</h2><p>提升性能</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><ul>
<li><p>客户端</p>
<p>主要对浏览器的静态资源进行缓存，通过在浏览器端设置Expires（过期时间点）或者Cache-Control（时间段）来告诉浏览器将资源缓存到客户端本地，从而减少多次请求同一个静态资源带来的带宽和响应时效上的损耗。</p>
</li>
<li><p>应用层</p>
<ul>
<li>主要表现形式为CDN（Content Delivery Network），可以有效解决带宽集中占用以及数据分发的问题。</li>
<li>通过Nginx实现负载均衡，将静态资源存储在Nginx服务器上，并开启压缩功能；</li>
</ul>
</li>
<li><p>服务层</p>
<ul>
<li>进程内缓存：比如Mybatis的一二级缓存，或者Spring框架中的@EnableCache注解。</li>
<li>进程外缓存：典型的使用redis作为分布式缓存技术。</li>
</ul>
</li>
<li><p>数据层</p>
</li>
</ul>
<h2 id="分布式缓存引入的问题"><a href="#分布式缓存引入的问题" class="headerlink" title="分布式缓存引入的问题"></a>分布式缓存引入的问题</h2><p>数据一致性</p>
<h2 id="如何保证数据一致性"><a href="#如何保证数据一致性" class="headerlink" title="如何保证数据一致性"></a>如何保证数据一致性</h2><p>引入消息队列的主动推送功能，推送变更消息</p>
<h2 id="什么情况下适用多级缓存架构"><a href="#什么情况下适用多级缓存架构" class="headerlink" title="什么情况下适用多级缓存架构"></a>什么情况下适用多级缓存架构</h2><ol>
<li>缓存数据稳定</li>
<li>可能产生高并发场景，应用启动时进行预热处理，访问前将热点数据先缓存，减少后端压力</li>
<li>一定程度上允许数据不一致不重要的信息更新处理方式：T+1，ETL日中处理。</li>
</ol>
]]></content>
      <categories>
        <category>it老齐</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务导论</title>
    <url>/2021/11/23/microservices-theory-guide/</url>
    <content><![CDATA[<p>“微服务”——一个在当前种类繁多的软件架构中出现的新术语。虽然我们对这种事的自然反应一般都是轻蔑的瞥一眼，但真正能吸引我们的其实是术语中描述的一种软件系统风格。我们在过去的几年中看到了有一些项目使用了这种风格，迄今为止，他们的结果大部分都是正面的，因此，我们很多的同事也将它作为了一种构建企业级应用的默认风格。但是，并没有太多的的信息来告诉我们微服务风格究竟是什么，以及怎么去实现它。</p>
<p>简而言之，微服务架构风格是一种由多个微小服务集合组成的单应用开发风格，其中的每一个微小服务都拥有自己的进程以及轻量级的交互机制，通常是一个基于HTTP的API。这些服务围绕业务能力单独构建，并且可以被全自动化部署机制实现各自独立部署。对于这些服务也有一个纯粹的最小集中化管理，通常他们可以用不同的编程语言以及不同的数据存储技术来实现。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud服务注册与发现组件——Eureka</title>
    <url>/2021/11/29/spring-cloud-component-eureka/</url>
    <content><![CDATA[<h2 id="Spring-Cloud之服务发现——Eureka-发音为-juә’ri-kә"><a href="#Spring-Cloud之服务发现——Eureka-发音为-juә’ri-kә" class="headerlink" title="Spring Cloud之服务发现——Eureka(发音为[juә’ri:kә])"></a>Spring Cloud之服务发现——Eureka(发音为[juә’ri:kә])</h2><ul>
<li><p>服务注册与发现以及反馈的实现流程：</p>
<ol>
<li>Provider将自己的节点信息发送到指定的服务注册机上；</li>
<li>服务注册机将Provider发送过来的信息保存在指定区域，等待Consumer查询；</li>
<li>Provider通过定期向服务注册机发送消息确保自己不会被注销，而当服务注册机长时间未收到某个Provider发送过来的信息时，会自动将该Provider注销。</li>
<li>当Provider网络地址发生变更时，会自动重新注册节点信息到服务注册机，避免了人工修改配置的问题。</li>
</ol>
</li>
<li><p>Eureka的实现机制:</p>
<ol>
<li>Eureka分为Server端和Client端，Server端提供服务发现的能力，当微服务节点启动时，会自动向Server端注册自己的节点信息，而Server端则负责存储这些节点信息，供服务调用者查询；</li>
<li>Client端一般和微服务集成，为微服务提供注册服务到Server端的能力，并从Server端获取最新的已注册服务列表的信息<strong>缓存</strong>到微服务端；</li>
<li>微服务启动后，会周期性（默认30s）向Server端发送心跳以防止被注销；</li>
<li>同时，Server端也会周期性（默认90s）的检查已注册的各个微服务是否仍然存活，如果超时，则注销该微服务的注册信息；</li>
</ol>
</li>
</ul>
<h2 id="Eureka的基础实现"><a href="#Eureka的基础实现" class="headerlink" title="Eureka的基础实现"></a>Eureka的基础实现</h2><ul>
<li>Server端实现</li>
</ul>
<p>首先创建一个基础的SpringBoot工程，假设是Maven工程，在POM文件中引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在启动类中加入注解<code>@EnableEurekaService</code>，声明这是一个Server实例。</p>
<p>在<code>application.yml</code>中加入如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">	<span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">	<span class="attr">serviceUrl:</span></span><br><span class="line">		<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Client端实现</li>
</ul>
<p>首先创建一个基础的SpringBoot工程，假设是Maven工程，在POM文件中引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>application.yml</code>中加入如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microsoftservice-provider-user</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">serviceUrl:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line">	<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="高可用Eureka实现"><a href="#高可用Eureka实现" class="headerlink" title="高可用Eureka实现"></a>高可用Eureka实现</h2><p>单节点的Eureka无法满足线上环境高可用的要求。一旦发生故障，轻则影响服务的可达性，重则引发服务瘫痪，因此，以集群的方式部署Eureka是非常必要的。</p>
<h2 id="Eureka主页访问认证实现"><a href="#Eureka主页访问认证实现" class="headerlink" title="Eureka主页访问认证实现"></a>Eureka主页访问认证实现</h2><h2 id="非JVM的微服务注册与发现"><a href="#非JVM的微服务注册与发现" class="headerlink" title="非JVM的微服务注册与发现"></a>非JVM的微服务注册与发现</h2><h2 id="Eureka的自我保护模式实现"><a href="#Eureka的自我保护模式实现" class="headerlink" title="Eureka的自我保护模式实现"></a>Eureka的自我保护模式实现</h2>]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql学习资源</title>
    <url>/2021/12/22/postgresql-study-resource/</url>
    <content><![CDATA[<h2 id="1-postgresql在arch-linux上的安装和初始化"><a href="#1-postgresql在arch-linux上的安装和初始化" class="headerlink" title="1. postgresql在arch linux上的安装和初始化"></a>1. postgresql在arch linux上的安装和初始化</h2><p><a href="https://www.cnblogs.com/lemos/p/11605557.html">https://www.cnblogs.com/lemos/p/11605557.html</a></p>
<h2 id="2-postgresql语法"><a href="#2-postgresql语法" class="headerlink" title="2. postgresql语法"></a>2. postgresql语法</h2><p><a href="https://www.runoob.com/postgresql/postgresql-syntax.html">https://www.runoob.com/postgresql/postgresql-syntax.html</a></p>
<h2 id="3-postgresql官方文档"><a href="#3-postgresql官方文档" class="headerlink" title="3. postgresql官方文档"></a>3. postgresql官方文档</h2><p><a href="https://www.postgresql.org/docs/current/sql-createfunction.html">https://www.postgresql.org/docs/current/sql-createfunction.html</a></p>
]]></content>
      <categories>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>resource</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是jwt</title>
    <url>/2021/12/18/what-is-jwt-in-java/</url>
    <content><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>JWT（Json Web Token）以JSON的格式传输网络安全认证消息，以一种轻量级的消息传输格式来确保服务端的安全。而被传输的JSON信息可以被认证和信任，因为它拥有可信的数字签名。</p>
<p>客户端只需要使用凭证在服务器端认证一次，认证成功之后，服务端会给客户端返回一个JWT，客户端未来的请求都可以使用这个JWT来通过服务端的认证,并且不需要再次发送认证信息，比如说用户名和密码。</p>
<p><img src="/home/pengkai/.config/Typora/typora-user-images/image-20211218220701216.png" alt="image-20211218220701216"></p>
<p>需要注意的是，JWT中的payload对每个人都是可见的，因此我们不应该放任何敏感信息比如说密码在其中。我们可以加密payload数据，这样可以让它更加安全。然而我们可以确保没有人可以篡改payload中的信息。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>authenticate</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql常用查询场景</title>
    <url>/2021/12/23/postgresql-in-common-use-form/</url>
    <content><![CDATA[<h2 id="1-计算数组类型的元素之和"><a href="#1-计算数组类型的元素之和" class="headerlink" title="1. 计算数组类型的元素之和"></a>1. 计算数组类型的元素之和</h2><p>首先创建包含数组类型字段的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sal_emp (</span><br><span class="line">    name            text,</span><br><span class="line">    pay_by_quarter  <span class="type">integer</span>[<span class="number">4</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中<code>pay_by_quarter</code>表示每个季度的工资数组，数组长度为4。</p>
<p>需求：求指定季度区间内的工资总和。</p>
<p>插入测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sal_emp</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;Bill&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;10000, 10000, 10000, 10000&#125;&#x27;</span></span><br><span class="line">   )</span><br></pre></td></tr></table></figure>

<p>由于<code>postgresql</code>本身支持按照索引取值，还支持按照索引范围取值，所以，很自然想到使用区间值来实现求和的首尾季度，但如何求和呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pay_by_quarter[<span class="number">1</span>:<span class="number">4</span>] <span class="keyword">from</span> sal_emp;</span><br></pre></td></tr></table></figure>

<p>查询结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pay_by_quarter           <span class="operator">|</span></span><br><span class="line"><span class="comment">-------------------------+</span></span><br><span class="line">[<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>]<span class="operator">|</span></span><br></pre></td></tr></table></figure>

<p>如何将这4个数字累加起来呢，你可能想到使用<code>sum</code>函数来求和，但很遗憾，sum并不支持数组类型的求和。那么，我们可不可以将数组内的数字拆分成4条数据呢，当然可以。使用<code>unnest</code>函数可以帮我们做到这一点。</p>
<p>所以最后的<code>sql</code>变成了这样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	<span class="built_in">sum</span>(t.arr) </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    	<span class="keyword">select</span></span><br><span class="line">    		<span class="built_in">unnest</span>(pay_by_quarter[<span class="number">1</span>:<span class="number">4</span>]) arr</span><br><span class="line">    	<span class="keyword">from</span> sal_emp</span><br><span class="line">	) t</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sum  <span class="operator">|</span></span><br><span class="line"><span class="comment">-----+</span></span><br><span class="line"><span class="number">40000</span><span class="operator">|</span></span><br></pre></td></tr></table></figure>

<p>正是我们想要的求和之后的结果。</p>
]]></content>
      <categories>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>常用</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习资源</title>
    <url>/2021/12/31/c-plus-plus-study-resource/</url>
    <content><![CDATA[<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p><a href="https://www.softwaretestinghelp.com/cpp-tutorials/">https://www.softwaretestinghelp.com/cpp-tutorials/</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>如何在centos上管理软件包</title>
    <url>/2022/01/12/centos-software-management/</url>
    <content><![CDATA[<h2 id="1-使用YUM进行软件的管理"><a href="#1-使用YUM进行软件的管理" class="headerlink" title="1. 使用YUM进行软件的管理"></a>1. 使用YUM进行软件的管理</h2><h3 id="查看软件包的信息"><a href="#查看软件包的信息" class="headerlink" title="查看软件包的信息"></a>查看软件包的信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info 包名</span><br></pre></td></tr></table></figure>

<h3 id="查看软件包的依赖列表"><a href="#查看软件包的依赖列表" class="headerlink" title="查看软件包的依赖列表"></a>查看软件包的依赖列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum deplist 包名</span><br></pre></td></tr></table></figure>

<h3 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove 包名</span><br></pre></td></tr></table></figure>

<h3 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure>

<h3 id="查看仓库内可用的软件包"><a href="#查看仓库内可用的软件包" class="headerlink" title="查看仓库内可用的软件包"></a>查看仓库内可用的软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list available</span><br></pre></td></tr></table></figure>

<h3 id="清除所有的包缓存"><a href="#清除所有的包缓存" class="headerlink" title="清除所有的包缓存"></a>清除所有的包缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clear all</span><br></pre></td></tr></table></figure>



<h2 id="2-使用RPM进行软件管理"><a href="#2-使用RPM进行软件管理" class="headerlink" title="2. 使用RPM进行软件管理"></a>2. 使用RPM进行软件管理</h2><h3 id="查看已经安装的软件包"><a href="#查看已经安装的软件包" class="headerlink" title="查看已经安装的软件包"></a>查看已经安装的软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></table></figure>

<h3 id="查看某个已经被安装的软件包的信息"><a href="#查看某个已经被安装的软件包的信息" class="headerlink" title="查看某个已经被安装的软件包的信息"></a>查看某个已经被安装的软件包的信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qi 包名</span><br></pre></td></tr></table></figure>

<h3 id="查看某个包的安装文件列表"><a href="#查看某个包的安装文件列表" class="headerlink" title="查看某个包的安装文件列表"></a>查看某个包的安装文件列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ql 包名</span><br></pre></td></tr></table></figure>

<h3 id="查看某个rpm包的详细信息"><a href="#查看某个rpm包的详细信息" class="headerlink" title="查看某个rpm包的详细信息"></a>查看某个rpm包的详细信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qip 包名.rpm</span><br></pre></td></tr></table></figure>

<h3 id="查看某个rpm包中将要被安装的文件列表"><a href="#查看某个rpm包中将要被安装的文件列表" class="headerlink" title="查看某个rpm包中将要被安装的文件列表"></a>查看某个rpm包中将要被安装的文件列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qlp 包名.rpm</span><br></pre></td></tr></table></figure>

<h3 id="查看某个目录或者文件对应的包"><a href="#查看某个目录或者文件对应的包" class="headerlink" title="查看某个目录或者文件对应的包"></a>查看某个目录或者文件对应的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qf 文件或者目录</span><br></pre></td></tr></table></figure>

<h3 id="查看某个已经安装的包的依赖"><a href="#查看某个已经安装的包的依赖" class="headerlink" title="查看某个已经安装的包的依赖"></a>查看某个已经安装的包的依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qR 包名</span><br></pre></td></tr></table></figure>

<h3 id="查看某个没有被安装的包的依赖项"><a href="#查看某个没有被安装的包的依赖项" class="headerlink" title="查看某个没有被安装的包的依赖项"></a>查看某个没有被安装的包的依赖项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qRp 包名.rpm</span><br></pre></td></tr></table></figure>

<h3 id="验证某个包的文件是否被正确安装"><a href="#验证某个包的文件是否被正确安装" class="headerlink" title="验证某个包的文件是否被正确安装"></a>验证某个包的文件是否被正确安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -V 包名</span><br></pre></td></tr></table></figure>



























]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>java中常用的文件操作工具</title>
    <url>/2022/01/10/common-file-util-of-java/</url>
    <content><![CDATA[<h2 id="使用的类库"><a href="#使用的类库" class="headerlink" title="使用的类库"></a>使用的类库</h2><p>apache的公共工具包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## build.gradle</span></span><br><span class="line">implementation <span class="string">&#x27;commons-io:commons-io:2.11.0&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="文件和目录操作类"><a href="#文件和目录操作类" class="headerlink" title="文件和目录操作类"></a>文件和目录操作类</h2><ol>
<li><p>FileUtils</p>
<ul>
<li><strong>[private]</strong> addCopyAttributes:如果原copy option中不存在复制选项，则在赋值选项中追加一个<code>StandardCopyOption.COPY_ATTRIBUTES</code></li>
<li></li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>util</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile在C++中的使用</title>
    <url>/2021/12/30/how-makefile-is-working-in-c-plus-plus/</url>
    <content><![CDATA[<h2 id="Make工具"><a href="#Make工具" class="headerlink" title="Make工具"></a>Make工具</h2><p>Make是unix上被用来简化为一个工程中的各个不同模块构建可执行程序的工具。在Makefile中有各种各样的规则来指定目标入口。make工具则读取所有的这些规则并依照行事。</p>
<p>例如，如果一个规则指定了某个依赖，那么make工具将在编译时包含这个依赖。make命令利用makefile来完成模块构建和文件清理的工作。</p>
<p>make的常用语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make target_label <span class="comment"># target_label是在makefile中指定的目标</span></span><br></pre></td></tr></table></figure>

<p>例如，如果我们想要执行清理文件的操作，那么我们可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean <span class="comment"># 注意，clean实际上是指定了rm作为执行命令</span></span><br></pre></td></tr></table></figure>

<h2 id="C-Makefile"><a href="#C-Makefile" class="headerlink" title="C++ Makefile"></a>C++ Makefile</h2><p>Makefile是一个由make命令来使用并用来构建目标的纯文本文件。一个Makefile也包含了一些源码级别的依赖信息以及构建顺序。</p>
<p>现在让我们看看Makefile的通用结构：</p>
<p>一个典型的Makefile通常以一个变量声明开头，后面紧跟着一串用来构建指定目标的目标入口。这些目标可能是<code>.o</code>或者是其他的可执行文件，比如说<code>C</code>或者<code>C++</code>或者<code>java</code>的<code>.class</code>文件。</p>
<p>我们还可以有一串被目标标识（target label)所指定并被用来执行一系列命令的目标入口。</p>
<p>因此一个通用的makefile大致如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># comment</span></span><br><span class="line"><span class="section">target: dependency1 dependency2 ... dependencyn</span></span><br><span class="line">	command</span><br><span class="line"><span class="comment"># 注意，command前面的tab缩进对于make来说是必要的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定编译器，g++代表C++编译器，gcc代表C编译器</span></span><br><span class="line">CC = g++</span><br><span class="line"><span class="comment"># 编译器flags</span></span><br><span class="line"><span class="comment"># -g表示需要添加debug信息到可执行文件中</span></span><br><span class="line"><span class="comment"># -Wall表示打开大多数编译器警告</span></span><br><span class="line">CFLAGS = -g -Wall</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">TARGET = main</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(TARGET)</span></span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(TARGET)</span>.cpp</span><br><span class="line">			<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(TARGET)</span>.cpp</span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">		<span class="variable">$(RM)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h2 id="Make和Makefile的例子"><a href="#Make和Makefile的例子" class="headerlink" title="Make和Makefile的例子"></a>Make和Makefile的例子</h2><p>假设我们的工程有如下几个文件：</p>
<ul>
<li>Main.cpp：主程序</li>
<li>Point.h：point类的头文件</li>
<li>Point.cpp：Point类的实现类</li>
<li>Square.h：square的头文件</li>
<li>Square.cpp：square类的实现类</li>
</ul>
<p>对于上面的几个文件，我们需要将这些文件各自编译并生成<code>.o</code>文件，然后将它们<code>link</code>成一个叫做<code>main</code>的可执行文件。</p>
<p>接下来我们将各自编译这些文件：</p>
<ul>
<li>g++ -c main.cpp：生成main.o</li>
<li>g++ -c point.cpp：生成point.o</li>
<li>g++ -c square.cpp：生成square.o</li>
</ul>
<p>接下来，我们需要将这些<code>.o</code>文件<code>link</code>成一个可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o main main.o point.o square.o</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要确定当某个文件发生变更时需要重新编译和重新生成的其他关联文件。下图描述了这种依赖关系。</p>
<p><img src="/home/pengkai/.config/Typora/typora-user-images/image-20211230234102091.png" alt="image-20211230234102091"></p>
<p>在上面的依赖图中，我们可以看到<code>main</code>位于根部，而<code>main</code>又包含了对象文件<code>main.o</code>、<code>point.o</code>、<code>square.o</code>，它们分别由各自的cpp文件编译生成。</p>
<p>所有的cpp实现都使用了它们自己的头文件，而<code>main.cpp</code>又引用了<code>point.h</code>和<code>square.h</code>。</p>
<p>接下来<code>point.cpp</code>引用了<code>point.h</code>。<code>square.cpp</code>引用了<code>square.h</code>和<code>point.h</code>。</p>
<p>如果我们的工程中只有少数几个文件，那么我们可以不用关系它们之间的依赖关系，但是，实际项目中，我们可能会有成百上千个文件，如果我们每次修改完一个文件之后都要手动编译和生成所有文件，那无疑是令人崩溃的。因此，我们需要使用make工具来帮我们简化这个流程。</p>
<blockquote>
<p> 注意，必须使用Makefile作为文件名，不区分大小写，且放在源代码的根目录。</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = g++</span><br><span class="line">CFLAGS = -wall -g</span><br><span class="line"><span class="comment"># 确定依赖关系</span></span><br><span class="line"><span class="section">main: main.o Point.o Square.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o main main.o Point.o Square.o</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的命令实际上等价于我们在终端中执行</p>
<p>g++ -wall -g -o main main.o point.o square.o</p>
</blockquote>
<p>接下来我们需要生成对象文件：main.o、point.o、square.o</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.o: main.cpp point.h square.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c main.cpp</span><br><span class="line"><span class="section">Point.o: Point.h</span></span><br><span class="line"><span class="section">Square.o: Square.h Point.h</span></span><br></pre></td></tr></table></figure>

<h2 id="Makefile的优点"><a href="#Makefile的优点" class="headerlink" title="Makefile的优点"></a>Makefile的优点</h2><ul>
<li>对于大项目，可以让我们以系统性和更有效的方式呈现项目；</li>
<li>可以让源代码更加有效和易读，并利于debug；</li>
<li>Makefile可以自动编译那些被修改过的文件，因此当发生文件变更时我们不需要手动重新生成整个项目。</li>
<li>Makefile允许我们一次编译多个文件，因此我们只需要一个步骤就可以完成整个项目的编译。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>java和c++的区别</title>
    <url>/2022/01/03/java-cpp-difference/</url>
    <content><![CDATA[<h2 id="java和c-的不同点"><a href="#java和c-的不同点" class="headerlink" title="java和c++的不同点"></a>java和c++的不同点</h2><table>
<thead>
<tr>
<th><strong>BASIS FOR</strong> <strong>COMPARISON</strong></th>
<th><strong>C++</strong></th>
<th><strong>Java</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Memory Management</strong></td>
<td>Managed by developers using pointers. Supports structures and union</td>
<td>Controlled by the system, does not use pointers. Supports Threads and Interfaces</td>
</tr>
<tr>
<td><strong>Inheritance</strong></td>
<td>Provide single and multiple inheritances both</td>
<td>Does not support multiple inheritances. Uses the concept of Interface to achieve</td>
</tr>
<tr>
<td><strong>Runtime error detection mechanism</strong></td>
<td>Programmer’s responsibility</td>
<td>System’s responsibility</td>
</tr>
<tr>
<td><strong>Libraries</strong></td>
<td>Comparatively available with low-level functionalities</td>
<td>Provide a wide range of classes for various high-level services</td>
</tr>
<tr>
<td><strong>Program Handling</strong></td>
<td>Methods and data can reside outside classes. The concept of a global file, namespace scopes available</td>
<td>All methods and data reside in the class itself. Concept od Package is used.</td>
</tr>
<tr>
<td><strong>Type Semantics</strong></td>
<td>Supports consistent support between primitive and object types</td>
<td>Different from primitive and object types</td>
</tr>
<tr>
<td><strong>Portability</strong></td>
<td>Platform dependent as source code must be recompiled for different platform.</td>
<td>It uses the concept of bytecode which is platform-independent and can be used with platform-specific JVM.</td>
</tr>
<tr>
<td><strong>Polymorphism</strong></td>
<td>Explicit for methods supports mixed hierarchies</td>
<td>Automatic uses static and dynamic binding</td>
</tr>
</tbody></table>
<p>参考文章：<a href="https://www.educba.com/c-plus-plus-vs-java/">https://www.educba.com/c-plus-plus-vs-java/</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中指针和引用的使用</title>
    <url>/2022/01/03/pointer-and-reference-in-cpp/</url>
    <content><![CDATA[<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>指针是一个持有某个变量内存地址的特殊变量，使用<code>*</code>号表示。</p>
<p>引用类似于指针，一般可以认为是持有某个值的变量的别名，它被用来关联被赋值给它的变量，使用<code>&amp;</code>表示。</p>
<p>引用存储的是变量的地址。</p>
<p>语法层面的区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody><tr>
<td>是否可以为null</td>
<td>可以指向一个null</td>
<td>不能为null，否则会报异常</td>
</tr>
<tr>
<td>声明方式</td>
<td>使用<code>*</code>号声明</td>
<td>使用<code>&amp;</code>声明</td>
</tr>
<tr>
<td>是否可以级联</td>
<td>可以级联声明<br />int *ptr;<br />int **ptr1;<br />int x = 10;<br />int y = 20;<br />ptr = &x;<br />ptr1 = &ptr;</td>
<td></td>
</tr>
<tr>
<td>是否可以重新赋值</td>
<td>可以</td>
<td>一旦变量被赋值给引用变量，那么这个引用变量将不能重新被赋值</td>
</tr>
<tr>
<td>是否可以做算术运算</td>
<td>可以</td>
<td>不可以</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>S.No.</strong></th>
<th><strong>Pointer</strong></th>
<th><strong>Reference</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>Pointers in C++ can be assigned to NULL values.</td>
<td>References in C++ can never be NULL else; it will throw an exception.</td>
</tr>
<tr>
<td>2.</td>
<td>To dereference a variable in the case of pointers, (*) operator is used</td>
<td>There is no need for referencing the variable; the variable name is simply used in case of reference in C++.</td>
</tr>
<tr>
<td>3.</td>
<td>Pointers allow multiple levels of indirection, which  means that pointer to pointer to pointer assigning and targeting is  possible. For example: int *ptr, int **ptr1; int x= 10; int y= 20; ptr = &x; ptr1 = &ptr;</td>
<td>No multiple levels of indirection are possible in the  case of references. Only a single level is applicable in references.  Implementing multiple levels in references in C++ throws a compiler  error to the user. For example, int a = 13; int &amp;ref = a; int &amp;&amp;ref1 = ref;</td>
</tr>
<tr>
<td>4.</td>
<td>A pointer can be reassigned to point to another variable. But the variable needs to be of the same type of variable. For example: int *p; Int x, y; p = &x; p = &y;</td>
<td>Once the variable is referred to by the reference variable, it cannot be reassigned to refer to another variable.</td>
</tr>
<tr>
<td>5.</td>
<td>All the arithmetic operations like addition,  subtraction, increment, etc., are possible in the case of pointers in  C++. This is known as Pointer arithmetic. For example: int arr [5] = {10, 20, 30, 40, 50}; int p = arr; for (int i =0; i&lt;5; i++) { cout &lt;&lt; *p &lt;&lt; endl; p++; }</td>
<td>Arithmetic operations are not possible in the case of  references. In C++, it will throw a compiler time error when it tries to do so. For example: int x = 10; int &amp;ref = x; cout &lt;&lt; ref++ &lt;&lt; endl;</td>
</tr>
<tr>
<td>6.</td>
<td>In the case of declaring a pointer in a C++ program, (*) operator is used before the pointer name. For example: int *ptr;</td>
<td>In the case of reference, the reference variable is  declared by using the (&amp;) operator before the reference variable,  which stands for the address. For example: Int a= 10; int &amp;ref = a;</td>
</tr>
<tr>
<td>7.</td>
<td>The pointer variable returns the value whose address it is pointing to. Value can be retrieved using the (*) operator.</td>
<td>The reference variable returns the address of the  address it is referring to. The address can be retrieved using the  (&amp;) operator.</td>
</tr>
<tr>
<td>8.</td>
<td>The pointer variable in C++ has its own address in computer memory, and it also occupies space in the stack.</td>
<td>The reference variable does not have its own memory  address; instead, it only points to the variable and shares the same  address as the original variable.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>design-pattern-with-java</title>
    <url>/2022/01/13/design-pattern-with-java/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vimrc配置教程</title>
    <url>/2022/01/16/vimrc-configure-tutorial/</url>
    <content><![CDATA[<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ul>
<li>set nocompatible：设置为不兼容vi</li>
<li>filetype on：自动检测文件类型</li>
<li>filetype plugin on：自动加载插件</li>
<li>filetype indent on：自动缩进</li>
<li>syntax on：语法高亮</li>
<li>set nu：开启行号</li>
<li>set cursorline：高亮光标所在的当前行</li>
<li>set cursorcolumn：高亮光标所在的当前列</li>
<li>set shiftwidth=4：设置shift的宽度为4个空格</li>
<li>set tabstop=4：设置tab的宽度为4列</li>
<li>set expandtab：使用空格代替tab的缩进</li>
<li>set nobackup：不保存备份文件</li>
</ul>
<h2 id="开箱即用的vimrc配置"><a href="#开箱即用的vimrc配置" class="headerlink" title="开箱即用的vimrc配置"></a>开箱即用的vimrc配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;               </span></span><br><span class="line"><span class="string">&quot;</span>               </span><br><span class="line"><span class="string">&quot;               ██╗   ██╗██╗███╗   ███╗██████╗  ██████╗</span></span><br><span class="line"><span class="string">&quot;</span>               ██║   ██║██║████╗ ████║██╔══██╗██╔════╝</span><br><span class="line"><span class="string">&quot;               ██║   ██║██║██╔████╔██║██████╔╝██║     </span></span><br><span class="line"><span class="string">&quot;</span>               ╚██╗ ██╔╝██║██║╚██╔╝██║██╔══██╗██║     </span><br><span class="line"><span class="string">&quot;                ╚████╔╝ ██║██║ ╚═╝ ██║██║  ██║╚██████╗</span></span><br><span class="line"><span class="string">&quot;</span>                 ╚═══╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝ ╚═════╝</span><br><span class="line"><span class="string">&quot;               </span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span><span class="string">&quot;&quot;</span>               </span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Disable compatibility with vi which can cause unexpected issues.</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Enable <span class="built_in">type</span> file detection. Vim will be able to try to detect the <span class="built_in">type</span> of file is use.</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Enable plugins and load plugin for the detected file type.</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Load an indent file <span class="keyword">for</span> the detected file <span class="built_in">type</span>.</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Turn syntax highlighting on.</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Add numbers to the file.</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Highlight cursor line underneath the cursor horizontally.</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Highlight cursor line underneath the cursor vertically.</span><br><span class="line"><span class="built_in">set</span> cursorcolumn</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Set shift width to 4 spaces.</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Set tab width to 4 columns.</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Use space characters instead of tabs.</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Do not save backup files.</span><br><span class="line"><span class="built_in">set</span> nobackup</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Do not let cursor scroll below or above N number of lines when scrolling.</span></span><br><span class="line"><span class="string">set scrolloff=10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Do not wrap lines. Allow long lines to extend as far as the line goes.</span><br><span class="line"><span class="built_in">set</span> nowrap</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; While searching though a file incrementally highlight matching characters as you type.</span></span><br><span class="line"><span class="string">set incsearch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Ignore capital letters during search.</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Override the ignorecase option if searching for capital letters.</span></span><br><span class="line"><span class="string">&quot;</span> This will allow you to search specifically <span class="keyword">for</span> capital letters.</span><br><span class="line"><span class="built_in">set</span> smartcase</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Show partial command you type in the last line of the screen.</span></span><br><span class="line"><span class="string">set showcmd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Show the mode you are on the last line.</span><br><span class="line"><span class="built_in">set</span> showmode</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Show matching words during a search.</span></span><br><span class="line"><span class="string">set showmatch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Use highlighting when doing a search.</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Set the commands to save in history default number is 20.</span></span><br><span class="line"><span class="string">set history=1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Enable auto completion menu after pressing TAB.</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Make wildmenu behave like similar to Bash completion.</span></span><br><span class="line"><span class="string">set wildmode=list:longest</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> There are certain files that we would never want to edit with Vim.</span><br><span class="line"><span class="string">&quot; Wildmenu will ignore files with these extensions.</span></span><br><span class="line"><span class="string">set wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.exe,*.flv,*.img,*.xlsx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> PLUGINS ---------------------------------------------------------------- &#123;&#123;&#123;</span><br><span class="line"></span><br><span class="line">call plug<span class="comment">#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"></span><br><span class="line">  Plug <span class="string">&#x27;dense-analysis/ale&#x27;</span></span><br><span class="line"></span><br><span class="line">  Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line"></span><br><span class="line">call plug<span class="comment">#end()</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; &#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> MAPPINGS --------------------------------------------------------------- &#123;&#123;&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Set the backslash as the leader key.</span></span><br><span class="line"><span class="string">let mapleader = &quot;</span>\&quot;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Press \\ to jump back to the last cursor position.</span></span><br><span class="line"><span class="string">nnoremap &lt;leader&gt;\ ``</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Press \p to <span class="built_in">print</span> the current file to the default printer from a Linux operating system.</span><br><span class="line"><span class="string">&quot; View available printers:   lpstat -v</span></span><br><span class="line"><span class="string">&quot;</span> Set default printer:       lpoptions -d &lt;printer_name&gt;</span><br><span class="line"><span class="string">&quot; &lt;silent&gt; means do not display output.</span></span><br><span class="line"><span class="string">nnoremap &lt;silent&gt; &lt;leader&gt;p :%w !lp&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Type jj to <span class="built_in">exit</span> insert mode quickly.</span><br><span class="line">inoremap jj &lt;Esc&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Press the space bar to type the : character in command mode.</span></span><br><span class="line"><span class="string">nnoremap &lt;space&gt; :</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Pressing the letter o will open a new line below the current one.</span><br><span class="line"><span class="string">&quot; Exit insert mode after creating a new line above or below the current line.</span></span><br><span class="line"><span class="string">nnoremap o o&lt;esc&gt;</span></span><br><span class="line"><span class="string">nnoremap O O&lt;esc&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Center the cursor vertically when moving to the next word during a search.</span><br><span class="line">nnoremap n nzz</span><br><span class="line">nnoremap N Nzz</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Yank from cursor to the end of line.</span></span><br><span class="line"><span class="string">nnoremap Y y$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Map the F5 key to run a Python script inside Vim.</span><br><span class="line"><span class="string">&quot; We map F5 to a chain of commands here.</span></span><br><span class="line"><span class="string">&quot;</span> :w saves the file.</span><br><span class="line"><span class="string">&quot; &lt;CR&gt; (carriage return) is like pressing the enter key.</span></span><br><span class="line"><span class="string">&quot;</span> !clear runs the external clear screen <span class="built_in">command</span>.</span><br><span class="line"><span class="string">&quot; !python3 % executes the current file with Python.</span></span><br><span class="line"><span class="string">nnoremap &lt;f5&gt; :w &lt;CR&gt;:!clear &lt;CR&gt;:!python3 % &lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> You can split the window <span class="keyword">in</span> Vim by typing :split or :vsplit.</span><br><span class="line"><span class="string">&quot; Navigate the split view easier by pressing CTRL+j, CTRL+k, CTRL+h, or CTRL+l.</span></span><br><span class="line"><span class="string">nnoremap &lt;c-j&gt; &lt;c-w&gt;j</span></span><br><span class="line"><span class="string">nnoremap &lt;c-k&gt; &lt;c-w&gt;k</span></span><br><span class="line"><span class="string">nnoremap &lt;c-h&gt; &lt;c-w&gt;h</span></span><br><span class="line"><span class="string">nnoremap &lt;c-l&gt; &lt;c-w&gt;l</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Resize split windows using arrow keys by pressing:</span><br><span class="line"><span class="string">&quot; CTRL+UP, CTRL+DOWN, CTRL+LEFT, or CTRL+RIGHT.</span></span><br><span class="line"><span class="string">noremap &lt;c-up&gt; &lt;c-w&gt;+</span></span><br><span class="line"><span class="string">noremap &lt;c-down&gt; &lt;c-w&gt;-</span></span><br><span class="line"><span class="string">noremap &lt;c-left&gt; &lt;c-w&gt;&gt;</span></span><br><span class="line"><span class="string">noremap &lt;c-right&gt; &lt;c-w&gt;&lt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> NERDTree specific mappings.</span><br><span class="line"><span class="string">&quot; Map the F3 key to toggle NERDTree open and close.</span></span><br><span class="line"><span class="string">nnoremap &lt;F3&gt; :NERDTreeToggle&lt;cr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> Have nerdtree ignore certain files and directories.</span><br><span class="line"><span class="built_in">let</span> NERDTreeIgnore=[<span class="string">&#x27;\.git$&#x27;</span>, <span class="string">&#x27;\.jpg$&#x27;</span>, <span class="string">&#x27;\.mp4$&#x27;</span>, <span class="string">&#x27;\.ogg$&#x27;</span>, <span class="string">&#x27;\.iso$&#x27;</span>, <span class="string">&#x27;\.pdf$&#x27;</span>, <span class="string">&#x27;\.pyc$&#x27;</span>, <span class="string">&#x27;\.odt$&#x27;</span>, <span class="string">&#x27;\.png$&#x27;</span>, <span class="string">&#x27;\.gif$&#x27;</span>, <span class="string">&#x27;\.db$&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; &#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> VIMSCRIPT -------------------------------------------------------------- &#123;&#123;&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Enable the marker method of folding.</span></span><br><span class="line"><span class="string">augroup filetype_vim</span></span><br><span class="line"><span class="string">    autocmd!</span></span><br><span class="line"><span class="string">    autocmd FileType vim setlocal foldmethod=marker</span></span><br><span class="line"><span class="string">augroup END</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> If the current file <span class="built_in">type</span> is HTML, <span class="built_in">set</span> indentation to 2 spaces.</span><br><span class="line">autocmd Filetype html setlocal tabstop=2 shiftwidth=2 expandtab</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; If Vim version is equal to or greater than 7.3 enable undofile.</span></span><br><span class="line"><span class="string">&quot;</span> This allows you to undo changes to a file even after saving it.</span><br><span class="line"><span class="keyword">if</span> version &gt;= 703</span><br><span class="line">    <span class="built_in">set</span> undodir=~/.vim/backup</span><br><span class="line">    <span class="built_in">set</span> undofile</span><br><span class="line">    <span class="built_in">set</span> undoreload=10000</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; You can split a window into sections by typing `:split` or `:vsplit`.</span></span><br><span class="line"><span class="string">&quot;</span> Display cursorline and cursorcolumn ONLY <span class="keyword">in</span> active window.</span><br><span class="line">augroup cursor_off</span><br><span class="line">    autocmd!</span><br><span class="line">    autocmd WinLeave * <span class="built_in">set</span> nocursorline nocursorcolumn</span><br><span class="line">    autocmd WinEnter * <span class="built_in">set</span> cursorline cursorcolumn</span><br><span class="line">augroup END</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; If GUI version of Vim is running set these options.</span></span><br><span class="line"><span class="string">if has(&#x27;gui_running&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Set the background tone.</span><br><span class="line">    <span class="built_in">set</span> background=dark</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot; Set the color scheme.</span></span><br><span class="line"><span class="string">    colorscheme molokai</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Set a custom font you have installed on your computer.</span><br><span class="line">    <span class="string">&quot; Syntax: &lt;font_name&gt;\ &lt;weight&gt;\ &lt;size&gt;</span></span><br><span class="line"><span class="string">    set guifont=Monospace\ Regular\ 12</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Display more of the file by default.</span><br><span class="line">    <span class="string">&quot; Hide the toolbar.</span></span><br><span class="line"><span class="string">    set guioptions-=T</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Hide the the left-side scroll bar.</span><br><span class="line">    <span class="built_in">set</span> guioptions-=L</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot; Hide the the left-side scroll bar.</span></span><br><span class="line"><span class="string">    set guioptions-=r</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Hide the the menu bar.</span><br><span class="line">    <span class="built_in">set</span> guioptions-=m</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot; Hide the the bottom scroll bar.</span></span><br><span class="line"><span class="string">    set guioptions-=b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span> Map the F4 key to toggle the menu, toolbar, and scroll bar.</span><br><span class="line">    <span class="string">&quot; &lt;Bar&gt; is the pipe character.</span></span><br><span class="line"><span class="string">    &quot;</span> &lt;CR&gt; is the enter key.</span><br><span class="line">    nnoremap &lt;F4&gt; :<span class="keyword">if</span> &amp;guioptions=~<span class="comment">#&#x27;mTr&#x27;&lt;Bar&gt;</span></span><br><span class="line">        \<span class="built_in">set</span> guioptions-=mTr&lt;Bar&gt;</span><br><span class="line">        \<span class="keyword">else</span>&lt;Bar&gt;</span><br><span class="line">        \<span class="built_in">set</span> guioptions+=mTr&lt;Bar&gt;</span><br><span class="line">        \endif&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; &#125;&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> STATUS LINE ------------------------------------------------------------ &#123;&#123;&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 状态条当vimrc重新加载的时候</span></span><br><span class="line"><span class="string">set statusline=</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 左侧的状态条</span><br><span class="line"><span class="built_in">set</span> statusline+=\ %F\ %M\ %Y\ %R</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 在左右边的中间部分添加分割条</span></span><br><span class="line"><span class="string">set statusline+=%=</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 右侧的状态条</span><br><span class="line"><span class="string">&quot;set statusline+=\ ascii:\ %b\ hex:\ 0x%B\ row:\ %l\ col:\ %c\ percent:\ %p%%</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 在倒数第二行展示状态条</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; &#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<a href="https://www.freecodecamp.org/news/vimrc-configuration-guide-customize-your-vim-editor/">https://www.freecodecamp.org/news/vimrc-configuration-guide-customize-your-vim-editor/</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 设置一个tab等于4个空格</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">&quot;</span> 智能使用tab键</span><br><span class="line"><span class="built_in">set</span> smarttab</span><br><span class="line"><span class="string">&quot; 使用空格代替tab</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">&quot;</span> 打开行号</span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="string">&quot; 开启自动缩进</span></span><br><span class="line"><span class="string">set ai</span></span><br><span class="line"><span class="string">&quot;</span> 开启智能缩进</span><br><span class="line"><span class="built_in">set</span> si</span><br><span class="line"><span class="string">&quot; 开启自动换行</span></span><br><span class="line"><span class="string">set wrap</span></span><br><span class="line"><span class="string">&quot;</span> 开启语法高亮</span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line"><span class="string">&quot; 高亮查询结果</span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string">&quot;</span> 查询时，智能判定大小写</span><br><span class="line"><span class="string">&quot; set smartcase(会覆盖ignorecase)</span></span><br><span class="line"><span class="string">&quot;</span> 查询时，忽略大小写</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="string">&quot; 显示文件名</span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string">if &amp;compatible</span></span><br><span class="line"><span class="string">    &quot;</span> 如果处于兼容模式，则设为非兼容模式，否则保持默认设置</span><br><span class="line">    <span class="built_in">set</span> nocompatible</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 设置jj为esc的快捷键</span></span><br><span class="line"><span class="string">inoremap jj &lt;esc&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 按需添加插件管理器</span><br><span class="line"><span class="keyword">function</span>! PackInit() abort</span><br><span class="line">    packadd minpac</span><br><span class="line">    call minpac<span class="comment">#init()</span></span><br><span class="line">    call minpac<span class="comment">#add(&#x27;tpope/vim-scriptease&#x27;,&#123;&#x27;type&#x27;:&#x27;opt&#x27;&#125;)</span></span><br><span class="line">    call minpac<span class="comment">#add(&#x27;k-takata/minpac&#x27;,&#123;&#x27;type&#x27;:&#x27;opt&#x27;&#125;)</span></span><br><span class="line">    call minpac<span class="comment">#add(&#x27;plasticboy/vim-markdown&#x27;)</span></span><br><span class="line">endfunction</span><br><span class="line"><span class="string">&quot; 快捷键，实时更新插件、实时删除插件、实时查看插件状态</span></span><br><span class="line"><span class="string">command! PackUpdate source <span class="variable">$MYVIMRC</span> | call PackInit() | call minpac#update()</span></span><br><span class="line"><span class="string">command! PackClean source <span class="variable">$MYVIMRC</span> | call PackInit() | call minpac#clean()</span></span><br><span class="line"><span class="string">command! PackStatus packadd minpac | call minpac#status()</span></span><br><span class="line"><span class="string">command! PackList packadd minpac | call minpac#status()</span></span><br><span class="line"><span class="string">nnoremap &lt;C-p&gt; :&lt;C-u&gt;FZF&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;C-s&gt; :&lt;C-u&gt;w&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vimrc</tag>
      </tags>
  </entry>
  <entry>
    <title>shell使用教程</title>
    <url>/2022/01/16/shell-basic-usage/</url>
    <content><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.shellscript.sh/loops.html">https://www.shellscript.sh/loops.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>shell script</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>debian包管理器使用手册</title>
    <url>/2022/01/18/debian-package-management-note/</url>
    <content><![CDATA[<h2 id="debian包的构成"><a href="#debian包的构成" class="headerlink" title="debian包的构成"></a>debian包的构成</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出deb包中的内容</span></span><br><span class="line">$ ar t dpkg_1.19.7_amd64.deb</span><br><span class="line">debian-binary</span><br><span class="line">control.tar.gz</span><br><span class="line">data.tar.xz</span><br><span class="line"><span class="comment"># 解压缩deb安装包</span></span><br><span class="line">$ ar x dpkg_1.19.7_amd64.deb</span><br><span class="line">$ ls</span><br><span class="line">control.tar.gz data.tar.xz debian-binary dpkg_1.19.7_amd64.deb</span><br><span class="line"><span class="comment"># 查看data.tar.xz包中的文件列表，并选择只展示前面的16行</span></span><br><span class="line">$ tar tJf data.tar.xz | head -n 16</span><br><span class="line">./</span><br><span class="line">./</span><br><span class="line">./etc/</span><br><span class="line">./etc/alternatives/</span><br><span class="line">./etc/alternatives/README</span><br><span class="line">./etc/cron.daily/</span><br><span class="line">./etc/cron.daily/dpkg</span><br><span class="line">./etc/dpkg/</span><br><span class="line">./etc/dpkg/dpkg.cfg</span><br><span class="line">./etc/dpkg/dpkg.cfg.d/</span><br><span class="line">./etc/logrotate.d/</span><br><span class="line">./etc/logrotate.d/alternatives</span><br><span class="line">./etc/logrotate.d/dpkg</span><br><span class="line">./sbin/</span><br><span class="line">./sbin/start-stop-daemon</span><br><span class="line">./usr/</span><br><span class="line">./usr/bin/</span><br><span class="line"><span class="comment"># 查看control.tar.xz包中的内容</span></span><br><span class="line">tar xJf control.tar.xz</span><br><span class="line">./</span><br><span class="line">./conffiles</span><br><span class="line">./control</span><br><span class="line">./md5sums</span><br><span class="line">./postinst</span><br><span class="line">./postrm</span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line">cat debian-binary</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<p>由此可见，Debian的deb存档格式主要由三个文件组成：</p>
<ul>
<li>debian-binary<br>  用来标识deb文件包的格式版本的文本文件，在Buster发行版中仍然是2.0。</li>
<li>control.tar.xz<br>  这个档案里面包含了所有的元信息，比如说包名和版本，以及一些安装之前或者中途或者之后的执行脚本。其中的一些元信息甚至允许包管理器工具根据包中列举出的文件是否已经安装或者有些文件是否已经被本地修改来决定能否安装或者卸载该软件。</li>
<li>data.tar.xz,data.tar.bz2,data.tar.gz<br>  这个档案中包含了所有将会从包中提取出来的文件，比如可执行文件，类库，文档等等。该档案可以使用不同的压缩格式，相应的，档案的名字也会根据压缩类型选择合适的后缀，比如<code>xz</code>，<code>bzip2</code>，<code>gzip</code>。<h2 id="软件包元信息"><a href="#软件包元信息" class="headerlink" title="软件包元信息"></a>软件包元信息</h2>未完待续…</li>
</ul>
]]></content>
      <categories>
        <category>debian</category>
      </categories>
      <tags>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>new-to-maven-local-repo</title>
    <url>/2022/01/17/new-to-maven-local-repo/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>debian10国内镜像</title>
    <url>/2022/01/19/debian-10-china-repo/</url>
    <content><![CDATA[<h2 id="国内使用debian-10的软件仓库地址"><a href="#国内使用debian-10的软件仓库地址" class="headerlink" title="国内使用debian 10的软件仓库地址"></a>国内使用debian 10的软件仓库地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian 10 buster</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中科大源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian buster main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian buster-updates main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian buster-backports main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free</span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian buster main contrib non-free</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian buster-updates main contrib non-free</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian buster-backports main contrib non-free</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb http://deb.debian.org/debian buster main contrib non-free</span></span><br><span class="line"><span class="comment"># deb http://deb.debian.org/debian buster-updates main contrib non-free</span></span><br><span class="line"><span class="comment"># deb http://deb.debian.org/debian-security/ buster/updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://deb.debian.org/debian buster main contrib non-free</span></span><br><span class="line"><span class="comment"># deb-src http://deb.debian.org/debian buster-updates main contrib non-free</span></span><br><span class="line"><span class="comment"># deb-src http://deb.debian.org/debian-security/ buster/updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网易源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb http://mirrors.163.com/debian/ buster main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.163.com/debian/ buster-updates main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.163.com/debian/ buster-backports main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.163.com/debian-security/ buster/updates main non-free contrib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-updates main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian/ buster-backports main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.163.com/debian-security/ buster/updates main non-free contrib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阿里云</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb http://mirrors.aliyun.com/debian/ buster main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib</span></span><br><span class="line"><span class="comment"># deb http://mirrors.aliyun.com/debian-security buster/updates main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.aliyun.com/debian-security buster/updates main</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>debian</category>
      </categories>
      <tags>
        <tag>mirror</tag>
      </tags>
  </entry>
</search>
